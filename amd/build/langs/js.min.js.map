{"version":3,"file":"js.min.js","sources":["../../src/langs/js.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n    if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n        mod(require(\"../../lib/codemirror\"));\n    else if (typeof define == \"function\" && define.amd) // AMD\n        define([\"mod_codescore/codemirrorlib\"], mod);\n    else // Plain browser env\n        mod(CodeMirror);\n})(function(CodeMirror) {\n    \"use strict\";\n\n    CodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n        var indentUnit = config.indentUnit;\n        var statementIndent = parserConfig.statementIndent;\n        var jsonldMode = parserConfig.jsonld;\n        var jsonMode = parserConfig.json || jsonldMode;\n        var trackScope = parserConfig.trackScope !== false\n        var isTS = parserConfig.typescript;\n        var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n        // Tokenizer\n\n        var keywords = function(){\n            function kw(type) {return {type: type, style: \"keyword\"};}\n            var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n            var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n            return {\n                \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n                \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n                \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n                \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n                \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n                \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n                \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n                \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n                \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n                \"await\": C\n            };\n        }();\n\n        var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n        var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n        function readRegexp(stream) {\n            var escaped = false, next, inSet = false;\n            while ((next = stream.next()) != null) {\n                if (!escaped) {\n                    if (next == \"/\" && !inSet) return;\n                    if (next == \"[\") inSet = true;\n                    else if (inSet && next == \"]\") inSet = false;\n                }\n                escaped = !escaped && next == \"\\\\\";\n            }\n        }\n\n        // Used as scratch variables to communicate multiple values without\n        // consing up tons of objects.\n        var type, content;\n        function ret(tp, style, cont) {\n            type = tp; content = cont;\n            return style;\n        }\n        function tokenBase(stream, state) {\n            var ch = stream.next();\n            if (ch == '\"' || ch == \"'\") {\n                state.tokenize = tokenString(ch);\n                return state.tokenize(stream, state);\n            } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n                return ret(\"number\", \"number\");\n            } else if (ch == \".\" && stream.match(\"..\")) {\n                return ret(\"spread\", \"meta\");\n            } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n                return ret(ch);\n            } else if (ch == \"=\" && stream.eat(\">\")) {\n                return ret(\"=>\", \"operator\");\n            } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n                return ret(\"number\", \"number\");\n            } else if (/\\d/.test(ch)) {\n                stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n                return ret(\"number\", \"number\");\n            } else if (ch == \"/\") {\n                if (stream.eat(\"*\")) {\n                    state.tokenize = tokenComment;\n                    return tokenComment(stream, state);\n                } else if (stream.eat(\"/\")) {\n                    stream.skipToEnd();\n                    return ret(\"comment\", \"comment\");\n                } else if (expressionAllowed(stream, state, 1)) {\n                    readRegexp(stream);\n                    stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n                    return ret(\"regexp\", \"string-2\");\n                } else {\n                    stream.eat(\"=\");\n                    return ret(\"operator\", \"operator\", stream.current());\n                }\n            } else if (ch == \"`\") {\n                state.tokenize = tokenQuasi;\n                return tokenQuasi(stream, state);\n            } else if (ch == \"#\" && stream.peek() == \"!\") {\n                stream.skipToEnd();\n                return ret(\"meta\", \"meta\");\n            } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n                return ret(\"variable\", \"property\")\n            } else if (ch == \"<\" && stream.match(\"!--\") ||\n                (ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start)))) {\n                stream.skipToEnd()\n                return ret(\"comment\", \"comment\")\n            } else if (isOperatorChar.test(ch)) {\n                if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n                    if (stream.eat(\"=\")) {\n                        if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n                    } else if (/[<>*+\\-|&?]/.test(ch)) {\n                        stream.eat(ch)\n                        if (ch == \">\") stream.eat(ch)\n                    }\n                }\n                if (ch == \"?\" && stream.eat(\".\")) return ret(\".\")\n                return ret(\"operator\", \"operator\", stream.current());\n            } else if (wordRE.test(ch)) {\n                stream.eatWhile(wordRE);\n                var word = stream.current()\n                if (state.lastType != \".\") {\n                    if (keywords.propertyIsEnumerable(word)) {\n                        var kw = keywords[word]\n                        return ret(kw.type, kw.style, word)\n                    }\n                    if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n                        return ret(\"async\", \"keyword\", word)\n                }\n                return ret(\"variable\", \"variable\", word)\n            }\n        }\n\n        function tokenString(quote) {\n            return function(stream, state) {\n                var escaped = false, next;\n                if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n                    state.tokenize = tokenBase;\n                    return ret(\"jsonld-keyword\", \"meta\");\n                }\n                while ((next = stream.next()) != null) {\n                    if (next == quote && !escaped) break;\n                    escaped = !escaped && next == \"\\\\\";\n                }\n                if (!escaped) state.tokenize = tokenBase;\n                return ret(\"string\", \"string\");\n            };\n        }\n\n        function tokenComment(stream, state) {\n            var maybeEnd = false, ch;\n            while (ch = stream.next()) {\n                if (ch == \"/\" && maybeEnd) {\n                    state.tokenize = tokenBase;\n                    break;\n                }\n                maybeEnd = (ch == \"*\");\n            }\n            return ret(\"comment\", \"comment\");\n        }\n\n        function tokenQuasi(stream, state) {\n            var escaped = false, next;\n            while ((next = stream.next()) != null) {\n                if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n                    state.tokenize = tokenBase;\n                    break;\n                }\n                escaped = !escaped && next == \"\\\\\";\n            }\n            return ret(\"quasi\", \"string-2\", stream.current());\n        }\n\n        var brackets = \"([{}])\";\n        // This is a crude lookahead trick to try and notice that we're\n        // parsing the argument patterns for a fat-arrow function before we\n        // actually hit the arrow token. It only works if the arrow is on\n        // the same line as the arguments and there's no strange noise\n        // (comments) in between. Fallback is to only notice when we hit the\n        // arrow, and not declare the arguments as locals for the arrow\n        // body.\n        function findFatArrow(stream, state) {\n            if (state.fatArrowAt) state.fatArrowAt = null;\n            var arrow = stream.string.indexOf(\"=>\", stream.start);\n            if (arrow < 0) return;\n\n            if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n                var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n                if (m) arrow = m.index\n            }\n\n            var depth = 0, sawSomething = false;\n            for (var pos = arrow - 1; pos >= 0; --pos) {\n                var ch = stream.string.charAt(pos);\n                var bracket = brackets.indexOf(ch);\n                if (bracket >= 0 && bracket < 3) {\n                    if (!depth) { ++pos; break; }\n                    if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n                } else if (bracket >= 3 && bracket < 6) {\n                    ++depth;\n                } else if (wordRE.test(ch)) {\n                    sawSomething = true;\n                } else if (/[\"'\\/`]/.test(ch)) {\n                    for (;; --pos) {\n                        if (pos == 0) return\n                        var next = stream.string.charAt(pos - 1)\n                        if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") { pos--; break }\n                    }\n                } else if (sawSomething && !depth) {\n                    ++pos;\n                    break;\n                }\n            }\n            if (sawSomething && !depth) state.fatArrowAt = pos;\n        }\n\n        // Parser\n\n        var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true,\n            \"regexp\": true, \"this\": true, \"import\": true, \"jsonld-keyword\": true};\n\n        function JSLexical(indented, column, type, align, prev, info) {\n            this.indented = indented;\n            this.column = column;\n            this.type = type;\n            this.prev = prev;\n            this.info = info;\n            if (align != null) this.align = align;\n        }\n\n        function inScope(state, varname) {\n            if (!trackScope) return false\n            for (var v = state.localVars; v; v = v.next)\n                if (v.name == varname) return true;\n            for (var cx = state.context; cx; cx = cx.prev) {\n                for (var v = cx.vars; v; v = v.next)\n                    if (v.name == varname) return true;\n            }\n        }\n\n        function parseJS(state, style, type, content, stream) {\n            var cc = state.cc;\n            // Communicate our context to the combinators.\n            // (Less wasteful than consing up a hundred closures on every call.)\n            cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n            if (!state.lexical.hasOwnProperty(\"align\"))\n                state.lexical.align = true;\n\n            while(true) {\n                var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n                if (combinator(type, content)) {\n                    while(cc.length && cc[cc.length - 1].lex)\n                        cc.pop()();\n                    if (cx.marked) return cx.marked;\n                    if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n                    return style;\n                }\n            }\n        }\n\n        // Combinator utils\n\n        var cx = {state: null, column: null, marked: null, cc: null};\n        function pass() {\n            for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n        }\n        function cont() {\n            pass.apply(null, arguments);\n            return true;\n        }\n        function inList(name, list) {\n            for (var v = list; v; v = v.next) if (v.name == name) return true\n            return false;\n        }\n        function register(varname) {\n            var state = cx.state;\n            cx.marked = \"def\";\n            if (!trackScope) return\n            if (state.context) {\n                if (state.lexical.info == \"var\" && state.context && state.context.block) {\n                    // FIXME function decls are also not block scoped\n                    var newContext = registerVarScoped(varname, state.context)\n                    if (newContext != null) {\n                        state.context = newContext\n                        return\n                    }\n                } else if (!inList(varname, state.localVars)) {\n                    state.localVars = new Var(varname, state.localVars)\n                    return\n                }\n            }\n            // Fall through means this is global\n            if (parserConfig.globalVars && !inList(varname, state.globalVars))\n                state.globalVars = new Var(varname, state.globalVars)\n        }\n        function registerVarScoped(varname, context) {\n            if (!context) {\n                return null\n            } else if (context.block) {\n                var inner = registerVarScoped(varname, context.prev)\n                if (!inner) return null\n                if (inner == context.prev) return context\n                return new Context(inner, context.vars, true)\n            } else if (inList(varname, context.vars)) {\n                return context\n            } else {\n                return new Context(context.prev, new Var(varname, context.vars), false)\n            }\n        }\n\n        function isModifier(name) {\n            return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n        }\n\n        // Combinators\n\n        function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n        function Var(name, next) { this.name = name; this.next = next }\n\n        var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n        function pushcontext() {\n            cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n            cx.state.localVars = defaultVars\n        }\n        function pushblockcontext() {\n            cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n            cx.state.localVars = null\n        }\n        pushcontext.lex = pushblockcontext.lex = true\n        function popcontext() {\n            cx.state.localVars = cx.state.context.vars\n            cx.state.context = cx.state.context.prev\n        }\n        popcontext.lex = true\n        function pushlex(type, info) {\n            var result = function() {\n                var state = cx.state, indent = state.indented;\n                if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n                else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n                    indent = outer.indented;\n                state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n            };\n            result.lex = true;\n            return result;\n        }\n        function poplex() {\n            var state = cx.state;\n            if (state.lexical.prev) {\n                if (state.lexical.type == \")\")\n                    state.indented = state.lexical.indented;\n                state.lexical = state.lexical.prev;\n            }\n        }\n        poplex.lex = true;\n\n        function expect(wanted) {\n            function exp(type) {\n                if (type == wanted) return cont();\n                else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n                else return cont(exp);\n            };\n            return exp;\n        }\n\n        function statement(type, value) {\n            if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n            if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n            if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n            if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n            if (type == \"debugger\") return cont(expect(\";\"));\n            if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n            if (type == \";\") return cont();\n            if (type == \"if\") {\n                if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n                    cx.state.cc.pop()();\n                return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n            }\n            if (type == \"function\") return cont(functiondef);\n            if (type == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n            if (type == \"class\" || (isTS && value == \"interface\")) {\n                cx.marked = \"keyword\"\n                return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n            }\n            if (type == \"variable\") {\n                if (isTS && value == \"declare\") {\n                    cx.marked = \"keyword\"\n                    return cont(statement)\n                } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n                    cx.marked = \"keyword\"\n                    if (value == \"enum\") return cont(enumdef);\n                    else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n                    else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n                } else if (isTS && value == \"namespace\") {\n                    cx.marked = \"keyword\"\n                    return cont(pushlex(\"form\"), expression, statement, poplex)\n                } else if (isTS && value == \"abstract\") {\n                    cx.marked = \"keyword\"\n                    return cont(statement)\n                } else {\n                    return cont(pushlex(\"stat\"), maybelabel);\n                }\n            }\n            if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                block, poplex, poplex, popcontext);\n            if (type == \"case\") return cont(expression, expect(\":\"));\n            if (type == \"default\") return cont(expect(\":\"));\n            if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n            if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n            if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n            if (type == \"async\") return cont(statement)\n            if (value == \"@\") return cont(expression, statement)\n            return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n        }\n        function maybeCatchBinding(type) {\n            if (type == \"(\") return cont(funarg, expect(\")\"))\n        }\n        function expression(type, value) {\n            return expressionInner(type, value, false);\n        }\n        function expressionNoComma(type, value) {\n            return expressionInner(type, value, true);\n        }\n        function parenExpr(type) {\n            if (type != \"(\") return pass()\n            return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex)\n        }\n        function expressionInner(type, value, noComma) {\n            if (cx.state.fatArrowAt == cx.stream.start) {\n                var body = noComma ? arrowBodyNoComma : arrowBody;\n                if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n                else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n            }\n\n            var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n            if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n            if (type == \"function\") return cont(functiondef, maybeop);\n            if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n            if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n            if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n            if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n            if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n            if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n            if (type == \"quasi\") return pass(quasi, maybeop);\n            if (type == \"new\") return cont(maybeTarget(noComma));\n            return cont();\n        }\n        function maybeexpression(type) {\n            if (type.match(/[;\\}\\)\\],]/)) return pass();\n            return pass(expression);\n        }\n\n        function maybeoperatorComma(type, value) {\n            if (type == \",\") return cont(maybeexpression);\n            return maybeoperatorNoComma(type, value, false);\n        }\n        function maybeoperatorNoComma(type, value, noComma) {\n            var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n            var expr = noComma == false ? expression : expressionNoComma;\n            if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n            if (type == \"operator\") {\n                if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n                if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n                    return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n                if (value == \"?\") return cont(expression, expect(\":\"), expr);\n                return cont(expr);\n            }\n            if (type == \"quasi\") { return pass(quasi, me); }\n            if (type == \";\") return;\n            if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n            if (type == \".\") return cont(property, me);\n            if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n            if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n            if (type == \"regexp\") {\n                cx.state.lastType = cx.marked = \"operator\"\n                cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n                return cont(expr)\n            }\n        }\n        function quasi(type, value) {\n            if (type != \"quasi\") return pass();\n            if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n            return cont(maybeexpression, continueQuasi);\n        }\n        function continueQuasi(type) {\n            if (type == \"}\") {\n                cx.marked = \"string-2\";\n                cx.state.tokenize = tokenQuasi;\n                return cont(quasi);\n            }\n        }\n        function arrowBody(type) {\n            findFatArrow(cx.stream, cx.state);\n            return pass(type == \"{\" ? statement : expression);\n        }\n        function arrowBodyNoComma(type) {\n            findFatArrow(cx.stream, cx.state);\n            return pass(type == \"{\" ? statement : expressionNoComma);\n        }\n        function maybeTarget(noComma) {\n            return function(type) {\n                if (type == \".\") return cont(noComma ? targetNoComma : target);\n                else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n                else return pass(noComma ? expressionNoComma : expression);\n            };\n        }\n        function target(_, value) {\n            if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n        }\n        function targetNoComma(_, value) {\n            if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n        }\n        function maybelabel(type) {\n            if (type == \":\") return cont(poplex, statement);\n            return pass(maybeoperatorComma, expect(\";\"), poplex);\n        }\n        function property(type) {\n            if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n        }\n        function objprop(type, value) {\n            if (type == \"async\") {\n                cx.marked = \"property\";\n                return cont(objprop);\n            } else if (type == \"variable\" || cx.style == \"keyword\") {\n                cx.marked = \"property\";\n                if (value == \"get\" || value == \"set\") return cont(getterSetter);\n                var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n                if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n                    cx.state.fatArrowAt = cx.stream.pos + m[0].length\n                return cont(afterprop);\n            } else if (type == \"number\" || type == \"string\") {\n                cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n                return cont(afterprop);\n            } else if (type == \"jsonld-keyword\") {\n                return cont(afterprop);\n            } else if (isTS && isModifier(value)) {\n                cx.marked = \"keyword\"\n                return cont(objprop)\n            } else if (type == \"[\") {\n                return cont(expression, maybetype, expect(\"]\"), afterprop);\n            } else if (type == \"spread\") {\n                return cont(expressionNoComma, afterprop);\n            } else if (value == \"*\") {\n                cx.marked = \"keyword\";\n                return cont(objprop);\n            } else if (type == \":\") {\n                return pass(afterprop)\n            }\n        }\n        function getterSetter(type) {\n            if (type != \"variable\") return pass(afterprop);\n            cx.marked = \"property\";\n            return cont(functiondef);\n        }\n        function afterprop(type) {\n            if (type == \":\") return cont(expressionNoComma);\n            if (type == \"(\") return pass(functiondef);\n        }\n        function commasep(what, end, sep) {\n            function proceed(type, value) {\n                if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n                    var lex = cx.state.lexical;\n                    if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n                    return cont(function(type, value) {\n                        if (type == end || value == end) return pass()\n                        return pass(what)\n                    }, proceed);\n                }\n                if (type == end || value == end) return cont();\n                if (sep && sep.indexOf(\";\") > -1) return pass(what)\n                return cont(expect(end));\n            }\n            return function(type, value) {\n                if (type == end || value == end) return cont();\n                return pass(what, proceed);\n            };\n        }\n        function contCommasep(what, end, info) {\n            for (var i = 3; i < arguments.length; i++)\n                cx.cc.push(arguments[i]);\n            return cont(pushlex(end, info), commasep(what, end), poplex);\n        }\n        function block(type) {\n            if (type == \"}\") return cont();\n            return pass(statement, block);\n        }\n        function maybetype(type, value) {\n            if (isTS) {\n                if (type == \":\") return cont(typeexpr);\n                if (value == \"?\") return cont(maybetype);\n            }\n        }\n        function maybetypeOrIn(type, value) {\n            if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr)\n        }\n        function mayberettype(type) {\n            if (isTS && type == \":\") {\n                if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n                else return cont(typeexpr)\n            }\n        }\n        function isKW(_, value) {\n            if (value == \"is\") {\n                cx.marked = \"keyword\"\n                return cont()\n            }\n        }\n        function typeexpr(type, value) {\n            if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n                cx.marked = \"keyword\"\n                return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n            }\n            if (type == \"variable\" || value == \"void\") {\n                cx.marked = \"type\"\n                return cont(afterType)\n            }\n            if (value == \"|\" || value == \"&\") return cont(typeexpr)\n            if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n            if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n            if (type == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType)\n            if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n            if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n            if (type == \"quasi\") { return pass(quasiType, afterType); }\n        }\n        function maybeReturnType(type) {\n            if (type == \"=>\") return cont(typeexpr)\n        }\n        function typeprops(type) {\n            if (type.match(/[\\}\\)\\]]/)) return cont()\n            if (type == \",\" || type == \";\") return cont(typeprops)\n            return pass(typeprop, typeprops)\n        }\n        function typeprop(type, value) {\n            if (type == \"variable\" || cx.style == \"keyword\") {\n                cx.marked = \"property\"\n                return cont(typeprop)\n            } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n                return cont(typeprop)\n            } else if (type == \":\") {\n                return cont(typeexpr)\n            } else if (type == \"[\") {\n                return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop)\n            } else if (type == \"(\") {\n                return pass(functiondecl, typeprop)\n            } else if (!type.match(/[;\\}\\)\\],]/)) {\n                return cont()\n            }\n        }\n        function quasiType(type, value) {\n            if (type != \"quasi\") return pass();\n            if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n            return cont(typeexpr, continueQuasiType);\n        }\n        function continueQuasiType(type) {\n            if (type == \"}\") {\n                cx.marked = \"string-2\";\n                cx.state.tokenize = tokenQuasi;\n                return cont(quasiType);\n            }\n        }\n        function typearg(type, value) {\n            if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n            if (type == \":\") return cont(typeexpr)\n            if (type == \"spread\") return cont(typearg)\n            return pass(typeexpr)\n        }\n        function afterType(type, value) {\n            if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n            if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n            if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n            if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n            if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n        }\n        function maybeTypeArgs(_, value) {\n            if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n        }\n        function typeparam() {\n            return pass(typeexpr, maybeTypeDefault)\n        }\n        function maybeTypeDefault(_, value) {\n            if (value == \"=\") return cont(typeexpr)\n        }\n        function vardef(_, value) {\n            if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n            return pass(pattern, maybetype, maybeAssign, vardefCont);\n        }\n        function pattern(type, value) {\n            if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n            if (type == \"variable\") { register(value); return cont(); }\n            if (type == \"spread\") return cont(pattern);\n            if (type == \"[\") return contCommasep(eltpattern, \"]\");\n            if (type == \"{\") return contCommasep(proppattern, \"}\");\n        }\n        function proppattern(type, value) {\n            if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n                register(value);\n                return cont(maybeAssign);\n            }\n            if (type == \"variable\") cx.marked = \"property\";\n            if (type == \"spread\") return cont(pattern);\n            if (type == \"}\") return pass();\n            if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n            return cont(expect(\":\"), pattern, maybeAssign);\n        }\n        function eltpattern() {\n            return pass(pattern, maybeAssign)\n        }\n        function maybeAssign(_type, value) {\n            if (value == \"=\") return cont(expressionNoComma);\n        }\n        function vardefCont(type) {\n            if (type == \",\") return cont(vardef);\n        }\n        function maybeelse(type, value) {\n            if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n        }\n        function forspec(type, value) {\n            if (value == \"await\") return cont(forspec);\n            if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n        }\n        function forspec1(type) {\n            if (type == \"var\") return cont(vardef, forspec2);\n            if (type == \"variable\") return cont(forspec2);\n            return pass(forspec2)\n        }\n        function forspec2(type, value) {\n            if (type == \")\") return cont()\n            if (type == \";\") return cont(forspec2)\n            if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n            return pass(expression, forspec2)\n        }\n        function functiondef(type, value) {\n            if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n            if (type == \"variable\") {register(value); return cont(functiondef);}\n            if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n            if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n        }\n        function functiondecl(type, value) {\n            if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n            if (type == \"variable\") {register(value); return cont(functiondecl);}\n            if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n            if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n        }\n        function typename(type, value) {\n            if (type == \"keyword\" || type == \"variable\") {\n                cx.marked = \"type\"\n                return cont(typename)\n            } else if (value == \"<\") {\n                return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n            }\n        }\n        function funarg(type, value) {\n            if (value == \"@\") cont(expression, funarg)\n            if (type == \"spread\") return cont(funarg);\n            if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n            if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n            return pass(pattern, maybetype, maybeAssign);\n        }\n        function classExpression(type, value) {\n            // Class expressions may have an optional name.\n            if (type == \"variable\") return className(type, value);\n            return classNameAfter(type, value);\n        }\n        function className(type, value) {\n            if (type == \"variable\") {register(value); return cont(classNameAfter);}\n        }\n        function classNameAfter(type, value) {\n            if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n            if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n                if (value == \"implements\") cx.marked = \"keyword\";\n                return cont(isTS ? typeexpr : expression, classNameAfter);\n            }\n            if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n        }\n        function classBody(type, value) {\n            if (type == \"async\" ||\n                (type == \"variable\" &&\n                    (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n                    cx.stream.match(/^\\s+#?[\\w$\\xa1-\\uffff]/, false))) {\n                cx.marked = \"keyword\";\n                return cont(classBody);\n            }\n            if (type == \"variable\" || cx.style == \"keyword\") {\n                cx.marked = \"property\";\n                return cont(classfield, classBody);\n            }\n            if (type == \"number\" || type == \"string\") return cont(classfield, classBody);\n            if (type == \"[\")\n                return cont(expression, maybetype, expect(\"]\"), classfield, classBody)\n            if (value == \"*\") {\n                cx.marked = \"keyword\";\n                return cont(classBody);\n            }\n            if (isTS && type == \"(\") return pass(functiondecl, classBody)\n            if (type == \";\" || type == \",\") return cont(classBody);\n            if (type == \"}\") return cont();\n            if (value == \"@\") return cont(expression, classBody)\n        }\n        function classfield(type, value) {\n            if (value == \"!\") return cont(classfield)\n            if (value == \"?\") return cont(classfield)\n            if (type == \":\") return cont(typeexpr, maybeAssign)\n            if (value == \"=\") return cont(expressionNoComma)\n            var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n            return pass(isInterface ? functiondecl : functiondef)\n        }\n        function afterExport(type, value) {\n            if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n            if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n            if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n            return pass(statement);\n        }\n        function exportField(type, value) {\n            if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n            if (type == \"variable\") return pass(expressionNoComma, exportField);\n        }\n        function afterImport(type) {\n            if (type == \"string\") return cont();\n            if (type == \"(\") return pass(expression);\n            if (type == \".\") return pass(maybeoperatorComma);\n            return pass(importSpec, maybeMoreImports, maybeFrom);\n        }\n        function importSpec(type, value) {\n            if (type == \"{\") return contCommasep(importSpec, \"}\");\n            if (type == \"variable\") register(value);\n            if (value == \"*\") cx.marked = \"keyword\";\n            return cont(maybeAs);\n        }\n        function maybeMoreImports(type) {\n            if (type == \",\") return cont(importSpec, maybeMoreImports)\n        }\n        function maybeAs(_type, value) {\n            if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n        }\n        function maybeFrom(_type, value) {\n            if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n        }\n        function arrayLiteral(type) {\n            if (type == \"]\") return cont();\n            return pass(commasep(expressionNoComma, \"]\"));\n        }\n        function enumdef() {\n            return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n        }\n        function enummember() {\n            return pass(pattern, maybeAssign);\n        }\n\n        function isContinuedStatement(state, textAfter) {\n            return state.lastType == \"operator\" || state.lastType == \",\" ||\n                isOperatorChar.test(textAfter.charAt(0)) ||\n                /[,.]/.test(textAfter.charAt(0));\n        }\n\n        function expressionAllowed(stream, state, backUp) {\n            return state.tokenize == tokenBase &&\n                /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n                (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n        }\n\n        // Interface\n\n        return {\n            startState: function(basecolumn) {\n                var state = {\n                    tokenize: tokenBase,\n                    lastType: \"sof\",\n                    cc: [],\n                    lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n                    localVars: parserConfig.localVars,\n                    context: parserConfig.localVars && new Context(null, null, false),\n                    indented: basecolumn || 0\n                };\n                if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n                    state.globalVars = parserConfig.globalVars;\n                return state;\n            },\n\n            token: function(stream, state) {\n                if (stream.sol()) {\n                    if (!state.lexical.hasOwnProperty(\"align\"))\n                        state.lexical.align = false;\n                    state.indented = stream.indentation();\n                    findFatArrow(stream, state);\n                }\n                if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n                var style = state.tokenize(stream, state);\n                if (type == \"comment\") return style;\n                state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n                return parseJS(state, style, type, content, stream);\n            },\n\n            indent: function(state, textAfter) {\n                if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n                if (state.tokenize != tokenBase) return 0;\n                var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n                // Kludge to prevent 'maybelse' from blocking lexical scope pops\n                if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n                    var c = state.cc[i];\n                    if (c == poplex) lexical = lexical.prev;\n                    else if (c != maybeelse && c != popcontext) break;\n                }\n                while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n                (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                    (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                    !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n                    lexical = lexical.prev;\n                if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n                    lexical = lexical.prev;\n                var type = lexical.type, closing = firstChar == type;\n\n                if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n                else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n                else if (type == \"form\") return lexical.indented + indentUnit;\n                else if (type == \"stat\")\n                    return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n                else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n                    return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n                else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n                else return lexical.indented + (closing ? 0 : indentUnit);\n            },\n\n            electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n            blockCommentStart: jsonMode ? null : \"/*\",\n            blockCommentEnd: jsonMode ? null : \"*/\",\n            blockCommentContinue: jsonMode ? null : \" * \",\n            lineComment: jsonMode ? null : \"//\",\n            fold: \"brace\",\n            closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n            helperType: jsonMode ? \"json\" : \"javascript\",\n            jsonldMode: jsonldMode,\n            jsonMode: jsonMode,\n\n            expressionAllowed: expressionAllowed,\n\n            skipExpression: function(state) {\n                parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null))\n            }\n        };\n    });\n\n    CodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\n    CodeMirror.defineMIME(\"text/javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\n    CodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\n    CodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true })\n    CodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\n    CodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\n    CodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});"],"names":["mod","CodeMirror","defineMode","config","parserConfig","type","content","indentUnit","statementIndent","jsonldMode","jsonld","jsonMode","json","trackScope","isTS","typescript","wordRE","wordCharacters","keywords","kw","style","A","B","C","D","operator","atom","isOperatorChar","isJsonldKeyword","ret","tp","cont","tokenBase","stream","state","quote","ch","next","tokenize","escaped","peek","match","test","eat","tokenComment","skipToEnd","expressionAllowed","inSet","readRegexp","current","tokenQuasi","eatWhile","string","slice","start","lexical","word","lastType","propertyIsEnumerable","maybeEnd","findFatArrow","fatArrowAt","arrow","indexOf","m","exec","index","depth","sawSomething","pos","charAt","bracket","atomicTypes","JSLexical","indented","column","align","prev","info","this","inScope","varname","v","localVars","name","cx","context","vars","parseJS","cc","marked","hasOwnProperty","length","pop","expression","statement","lex","pass","i","arguments","push","apply","inList","list","register","block","newContext","registerVarScoped","Var","globalVars","inner","Context","isModifier","defaultVars","pushcontext","pushblockcontext","popcontext","pushlex","result","indent","outer","poplex","expect","wanted","exp","value","vardef","parenExpr","maybeexpression","maybeelse","functiondef","forspec","className","enumdef","typename","typeexpr","pattern","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","body","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","classExpression","arrayLiteral","contCommasep","objprop","quasi","targetNoComma","target","maybeTypeArgs","maybeTarget","me","expr","property","backUp","continueQuasi","_","getterSetter","afterprop","maybetype","what","end","sep","proceed","maybetypeOrIn","mayberettype","isKW","afterType","typeprops","typearg","maybeReturnType","quasiType","typeprop","functiondecl","continueQuasiType","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","startState","basecolumn","token","sol","indentation","eatSpace","textAfter","Pass","top","firstChar","c","closing","isContinuedStatement","doubleIndentSwitch","electricInput","blockCommentStart","blockCommentEnd","blockCommentContinue","lineComment","fold","closeBrackets","helperType","skipExpression","StringStream","registerHelper","defineMIME","exports","module","require","define","amd"],"mappings":"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"}