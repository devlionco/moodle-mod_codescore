{"version":3,"file":"codemirrormerge.min.js","sources":["../src/codemirrormerge.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// declare global: diff_match_patch, DIFF_INSERT, DIFF_DELETE, DIFF_EQUAL\n\n/**\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nfunction diff_match_patch() {\n\n    // Defaults.\n    // Redefine these in your program to override the defaults.\n\n    // Number of seconds to map a diff before giving up (0 for infinity).\n    this.Diff_Timeout = 1.0;\n    // Cost of an empty edit operation in terms of edit characters.\n    this.Diff_EditCost = 4;\n    // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n    this.Match_Threshold = 0.5;\n    // How far to search for a match (0 = exact location, 1000+ = broad match).\n    // A match this many characters away from the expected location will add\n    // 1.0 to the score (0.0 is a perfect match).\n    this.Match_Distance = 1000;\n    // When deleting a large block of text (over ~64 characters), how close do\n    // the contents have to be to match the expected contents. (0.0 = perfection,\n    // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n    // end points of a delete need to match.\n    this.Patch_DeleteThreshold = 0.5;\n    // Chunk size for context length.\n    this.Patch_Margin = 4;\n\n    // The number of bits in an int.\n    this.Match_MaxBits = 32;\n}\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/** @typedef {{0: number, 1: string}} */\ndiff_match_patch.Diff;\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n                                                opt_deadline) {\n    // Set a deadline by which time the diff must be complete.\n    if (typeof opt_deadline == 'undefined') {\n        if (this.Diff_Timeout <= 0) {\n            opt_deadline = Number.MAX_VALUE;\n        } else {\n            opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n        }\n    }\n    var deadline = opt_deadline;\n\n    // Check for null inputs.\n    if (text1 == null || text2 == null) {\n        throw new Error('Null input. (diff_main)');\n    }\n\n    // Check for equality (speedup).\n    if (text1 == text2) {\n        if (text1) {\n            return [[DIFF_EQUAL, text1]];\n        }\n        return [];\n    }\n\n    if (typeof opt_checklines == 'undefined') {\n        opt_checklines = true;\n    }\n    var checklines = opt_checklines;\n\n    // Trim off common prefix (speedup).\n    var commonlength = this.diff_commonPrefix(text1, text2);\n    var commonprefix = text1.substring(0, commonlength);\n    text1 = text1.substring(commonlength);\n    text2 = text2.substring(commonlength);\n\n    // Trim off common suffix (speedup).\n    commonlength = this.diff_commonSuffix(text1, text2);\n    var commonsuffix = text1.substring(text1.length - commonlength);\n    text1 = text1.substring(0, text1.length - commonlength);\n    text2 = text2.substring(0, text2.length - commonlength);\n\n    // Compute the diff on the middle block.\n    var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n    // Restore the prefix and suffix.\n    if (commonprefix) {\n        diffs.unshift([DIFF_EQUAL, commonprefix]);\n    }\n    if (commonsuffix) {\n        diffs.push([DIFF_EQUAL, commonsuffix]);\n    }\n    this.diff_cleanupMerge(diffs);\n    return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n                                                    deadline) {\n    var diffs;\n\n    if (!text1) {\n        // Just add some text (speedup).\n        return [[DIFF_INSERT, text2]];\n    }\n\n    if (!text2) {\n        // Just delete some text (speedup).\n        return [[DIFF_DELETE, text1]];\n    }\n\n    var longtext = text1.length > text2.length ? text1 : text2;\n    var shorttext = text1.length > text2.length ? text2 : text1;\n    var i = longtext.indexOf(shorttext);\n    if (i != -1) {\n        // Shorter text is inside the longer text (speedup).\n        diffs = [[DIFF_INSERT, longtext.substring(0, i)],\n            [DIFF_EQUAL, shorttext],\n            [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n        // Swap insertions for deletions if diff is reversed.\n        if (text1.length > text2.length) {\n            diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n        }\n        return diffs;\n    }\n\n    if (shorttext.length == 1) {\n        // Single character string.\n        // After the previous speedup, the character can't be an equality.\n        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n    }\n\n    // Check to see if the problem can be split in two.\n    var hm = this.diff_halfMatch_(text1, text2);\n    if (hm) {\n        // A half-match was found, sort out the return data.\n        var text1_a = hm[0];\n        var text1_b = hm[1];\n        var text2_a = hm[2];\n        var text2_b = hm[3];\n        var mid_common = hm[4];\n        // Send both pairs off for separate processing.\n        var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n        var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n        // Merge the results.\n        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n    }\n\n    if (checklines && text1.length > 100 && text2.length > 100) {\n        return this.diff_lineMode_(text1, text2, deadline);\n    }\n\n    return this.diff_bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n    // Scan the text on a line-by-line basis first.\n    var a = this.diff_linesToChars_(text1, text2);\n    text1 = a.chars1;\n    text2 = a.chars2;\n    var linearray = a.lineArray;\n\n    var diffs = this.diff_main(text1, text2, false, deadline);\n\n    // Convert the diff back to original text.\n    this.diff_charsToLines_(diffs, linearray);\n    // Eliminate freak matches (e.g. blank lines)\n    this.diff_cleanupSemantic(diffs);\n\n    // Rediff any replacement blocks, this time character-by-character.\n    // Add a dummy entry at the end.\n    diffs.push([DIFF_EQUAL, '']);\n    var pointer = 0;\n    var count_delete = 0;\n    var count_insert = 0;\n    var text_delete = '';\n    var text_insert = '';\n    while (pointer < diffs.length) {\n        switch (diffs[pointer][0]) {\n            case DIFF_INSERT:\n                count_insert++;\n                text_insert += diffs[pointer][1];\n                break;\n            case DIFF_DELETE:\n                count_delete++;\n                text_delete += diffs[pointer][1];\n                break;\n            case DIFF_EQUAL:\n                // Upon reaching an equality, check for prior redundancies.\n                if (count_delete >= 1 && count_insert >= 1) {\n                    // Delete the offending records and add the merged ones.\n                    diffs.splice(pointer - count_delete - count_insert,\n                        count_delete + count_insert);\n                    pointer = pointer - count_delete - count_insert;\n                    var a = this.diff_main(text_delete, text_insert, false, deadline);\n                    for (var j = a.length - 1; j >= 0; j--) {\n                        diffs.splice(pointer, 0, a[j]);\n                    }\n                    pointer = pointer + a.length;\n                }\n                count_insert = 0;\n                count_delete = 0;\n                text_delete = '';\n                text_insert = '';\n                break;\n        }\n        pointer++;\n    }\n    diffs.pop();  // Remove the dummy entry at the end.\n\n    return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n    // Cache the text lengths to prevent multiple calls.\n    var text1_length = text1.length;\n    var text2_length = text2.length;\n    var max_d = Math.ceil((text1_length + text2_length) / 2);\n    var v_offset = max_d;\n    var v_length = 2 * max_d;\n    var v1 = new Array(v_length);\n    var v2 = new Array(v_length);\n    // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n    // integers and undefined.\n    for (var x = 0; x < v_length; x++) {\n        v1[x] = -1;\n        v2[x] = -1;\n    }\n    v1[v_offset + 1] = 0;\n    v2[v_offset + 1] = 0;\n    var delta = text1_length - text2_length;\n    // If the total number of characters is odd, then the front path will collide\n    // with the reverse path.\n    var front = (delta % 2 != 0);\n    // Offsets for start and end of k loop.\n    // Prevents mapping of space beyond the grid.\n    var k1start = 0;\n    var k1end = 0;\n    var k2start = 0;\n    var k2end = 0;\n    for (var d = 0; d < max_d; d++) {\n        // Bail out if deadline is reached.\n        if ((new Date()).getTime() > deadline) {\n            break;\n        }\n\n        // Walk the front path one step.\n        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n            var k1_offset = v_offset + k1;\n            var x1;\n            if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n                x1 = v1[k1_offset + 1];\n            } else {\n                x1 = v1[k1_offset - 1] + 1;\n            }\n            var y1 = x1 - k1;\n            while (x1 < text1_length && y1 < text2_length &&\n            text1.charAt(x1) == text2.charAt(y1)) {\n                x1++;\n                y1++;\n            }\n            v1[k1_offset] = x1;\n            if (x1 > text1_length) {\n                // Ran off the right of the graph.\n                k1end += 2;\n            } else if (y1 > text2_length) {\n                // Ran off the bottom of the graph.\n                k1start += 2;\n            } else if (front) {\n                var k2_offset = v_offset + delta - k1;\n                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n                    // Mirror x2 onto top-left coordinate system.\n                    var x2 = text1_length - v2[k2_offset];\n                    if (x1 >= x2) {\n                        // Overlap detected.\n                        return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n                    }\n                }\n            }\n        }\n\n        // Walk the reverse path one step.\n        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n            var k2_offset = v_offset + k2;\n            var x2;\n            if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n                x2 = v2[k2_offset + 1];\n            } else {\n                x2 = v2[k2_offset - 1] + 1;\n            }\n            var y2 = x2 - k2;\n            while (x2 < text1_length && y2 < text2_length &&\n            text1.charAt(text1_length - x2 - 1) ==\n            text2.charAt(text2_length - y2 - 1)) {\n                x2++;\n                y2++;\n            }\n            v2[k2_offset] = x2;\n            if (x2 > text1_length) {\n                // Ran off the left of the graph.\n                k2end += 2;\n            } else if (y2 > text2_length) {\n                // Ran off the top of the graph.\n                k2start += 2;\n            } else if (!front) {\n                var k1_offset = v_offset + delta - k2;\n                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n                    var x1 = v1[k1_offset];\n                    var y1 = v_offset + x1 - k1_offset;\n                    // Mirror x2 onto top-left coordinate system.\n                    x2 = text1_length - x2;\n                    if (x1 >= x2) {\n                        // Overlap detected.\n                        return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n                    }\n                }\n            }\n        }\n    }\n    // Diff took too long and hit the deadline or\n    // number of diffs equals number of characters, no commonality at all.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n                                                        deadline) {\n    var text1a = text1.substring(0, x);\n    var text2a = text2.substring(0, y);\n    var text1b = text1.substring(x);\n    var text2b = text2.substring(y);\n\n    // Compute both diffs serially.\n    var diffs = this.diff_main(text1a, text2a, false, deadline);\n    var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n    return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n    var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n    var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n    // '\\x00' is a valid character, but various debuggers don't like it.\n    // So we'll insert a junk entry to avoid generating a null character.\n    lineArray[0] = '';\n\n    /**\n     * Split a text into an array of strings.  Reduce the texts to a string of\n     * hashes where each Unicode character represents one line.\n     * Modifies linearray and linehash through being a closure.\n     * @param {string} text String to encode.\n     * @return {string} Encoded string.\n     * @private\n     */\n    function diff_linesToCharsMunge_(text) {\n        var chars = '';\n        // Walk the text, pulling out a substring for each line.\n        // text.split('\\n') would would temporarily double our memory footprint.\n        // Modifying text would create many large strings to garbage collect.\n        var lineStart = 0;\n        var lineEnd = -1;\n        // Keeping our own length variable is faster than looking it up.\n        var lineArrayLength = lineArray.length;\n        while (lineEnd < text.length - 1) {\n            lineEnd = text.indexOf('\\n', lineStart);\n            if (lineEnd == -1) {\n                lineEnd = text.length - 1;\n            }\n            var line = text.substring(lineStart, lineEnd + 1);\n            lineStart = lineEnd + 1;\n\n            if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n                (lineHash[line] !== undefined)) {\n                chars += String.fromCharCode(lineHash[line]);\n            } else {\n                chars += String.fromCharCode(lineArrayLength);\n                lineHash[line] = lineArrayLength;\n                lineArray[lineArrayLength++] = line;\n            }\n        }\n        return chars;\n    }\n\n    var chars1 = diff_linesToCharsMunge_(text1);\n    var chars2 = diff_linesToCharsMunge_(text2);\n    return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n    for (var x = 0; x < diffs.length; x++) {\n        var chars = diffs[x][1];\n        var text = [];\n        for (var y = 0; y < chars.length; y++) {\n            text[y] = lineArray[chars.charCodeAt(y)];\n        }\n        diffs[x][1] = text.join('');\n    }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n    // Quick check for common null cases.\n    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n        return 0;\n    }\n    // Binary search.\n    // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n    var pointermin = 0;\n    var pointermax = Math.min(text1.length, text2.length);\n    var pointermid = pointermax;\n    var pointerstart = 0;\n    while (pointermin < pointermid) {\n        if (text1.substring(pointerstart, pointermid) ==\n            text2.substring(pointerstart, pointermid)) {\n            pointermin = pointermid;\n            pointerstart = pointermin;\n        } else {\n            pointermax = pointermid;\n        }\n        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n    }\n    return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n    // Quick check for common null cases.\n    if (!text1 || !text2 ||\n        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n        return 0;\n    }\n    // Binary search.\n    // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n    var pointermin = 0;\n    var pointermax = Math.min(text1.length, text2.length);\n    var pointermid = pointermax;\n    var pointerend = 0;\n    while (pointermin < pointermid) {\n        if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n            text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n            pointermin = pointermid;\n            pointerend = pointermin;\n        } else {\n            pointermax = pointermid;\n        }\n        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n    }\n    return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n    // Cache the text lengths to prevent multiple calls.\n    var text1_length = text1.length;\n    var text2_length = text2.length;\n    // Eliminate the null case.\n    if (text1_length == 0 || text2_length == 0) {\n        return 0;\n    }\n    // Truncate the longer string.\n    if (text1_length > text2_length) {\n        text1 = text1.substring(text1_length - text2_length);\n    } else if (text1_length < text2_length) {\n        text2 = text2.substring(0, text1_length);\n    }\n    var text_length = Math.min(text1_length, text2_length);\n    // Quick check for the worst case.\n    if (text1 == text2) {\n        return text_length;\n    }\n\n    // Start by looking for a single character match\n    // and increase length until no match is found.\n    // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n    var best = 0;\n    var length = 1;\n    while (true) {\n        var pattern = text1.substring(text_length - length);\n        var found = text2.indexOf(pattern);\n        if (found == -1) {\n            return best;\n        }\n        length += found;\n        if (found == 0 || text1.substring(text_length - length) ==\n            text2.substring(0, length)) {\n            best = length;\n            length++;\n        }\n    }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n    if (this.Diff_Timeout <= 0) {\n        // Don't risk returning a non-optimal diff if we have unlimited time.\n        return null;\n    }\n    var longtext = text1.length > text2.length ? text1 : text2;\n    var shorttext = text1.length > text2.length ? text2 : text1;\n    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n        return null;  // Pointless.\n    }\n    var dmp = this;  // 'this' becomes 'window' in a closure.\n\n    /**\n     * Does a substring of shorttext exist within longtext such that the substring\n     * is at least half the length of longtext?\n     * Closure, but does not reference any external variables.\n     * @param {string} longtext Longer string.\n     * @param {string} shorttext Shorter string.\n     * @param {number} i Start index of quarter length substring within longtext.\n     * @return {Array.<string>} Five element Array, containing the prefix of\n     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n     *     of shorttext and the common middle.  Or null if there was no match.\n     * @private\n     */\n    function diff_halfMatchI_(longtext, shorttext, i) {\n        // Start with a 1/4 length substring at position i as a seed.\n        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n        var j = -1;\n        var best_common = '';\n        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n            var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                shorttext.substring(j));\n            var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                shorttext.substring(0, j));\n            if (best_common.length < suffixLength + prefixLength) {\n                best_common = shorttext.substring(j - suffixLength, j) +\n                    shorttext.substring(j, j + prefixLength);\n                best_longtext_a = longtext.substring(0, i - suffixLength);\n                best_longtext_b = longtext.substring(i + prefixLength);\n                best_shorttext_a = shorttext.substring(0, j - suffixLength);\n                best_shorttext_b = shorttext.substring(j + prefixLength);\n            }\n        }\n        if (best_common.length * 2 >= longtext.length) {\n            return [best_longtext_a, best_longtext_b,\n                best_shorttext_a, best_shorttext_b, best_common];\n        } else {\n            return null;\n        }\n    }\n\n    // First check if the second quarter is the seed for a half-match.\n    var hm1 = diff_halfMatchI_(longtext, shorttext,\n        Math.ceil(longtext.length / 4));\n    // Check again based on the third quarter.\n    var hm2 = diff_halfMatchI_(longtext, shorttext,\n        Math.ceil(longtext.length / 2));\n    var hm;\n    if (!hm1 && !hm2) {\n        return null;\n    } else if (!hm2) {\n        hm = hm1;\n    } else if (!hm1) {\n        hm = hm2;\n    } else {\n        // Both matched.  Select the longest.\n        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n    }\n\n    // A half-match was found, sort out the return data.\n    var text1_a, text1_b, text2_a, text2_b;\n    if (text1.length > text2.length) {\n        text1_a = hm[0];\n        text1_b = hm[1];\n        text2_a = hm[2];\n        text2_b = hm[3];\n    } else {\n        text2_a = hm[0];\n        text2_b = hm[1];\n        text1_a = hm[2];\n        text1_b = hm[3];\n    }\n    var mid_common = hm[4];\n    return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n    var changes = false;\n    var equalities = [];  // Stack of indices where equalities are found.\n    var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n    /** @type {?string} */\n    var lastequality = null;\n    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n    var pointer = 0;  // Index of current position.\n    // Number of characters that changed prior to the equality.\n    var length_insertions1 = 0;\n    var length_deletions1 = 0;\n    // Number of characters that changed after the equality.\n    var length_insertions2 = 0;\n    var length_deletions2 = 0;\n    while (pointer < diffs.length) {\n        if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n            equalities[equalitiesLength++] = pointer;\n            length_insertions1 = length_insertions2;\n            length_deletions1 = length_deletions2;\n            length_insertions2 = 0;\n            length_deletions2 = 0;\n            lastequality = diffs[pointer][1];\n        } else {  // An insertion or deletion.\n            if (diffs[pointer][0] == DIFF_INSERT) {\n                length_insertions2 += diffs[pointer][1].length;\n            } else {\n                length_deletions2 += diffs[pointer][1].length;\n            }\n            // Eliminate an equality that is smaller or equal to the edits on both\n            // sides of it.\n            if (lastequality && (lastequality.length <=\n                    Math.max(length_insertions1, length_deletions1)) &&\n                (lastequality.length <= Math.max(length_insertions2,\n                    length_deletions2))) {\n                // Duplicate record.\n                diffs.splice(equalities[equalitiesLength - 1], 0,\n                    [DIFF_DELETE, lastequality]);\n                // Change second copy to insert.\n                diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n                // Throw away the equality we just deleted.\n                equalitiesLength--;\n                // Throw away the previous equality (it needs to be reevaluated).\n                equalitiesLength--;\n                pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n                length_insertions1 = 0;  // Reset the counters.\n                length_deletions1 = 0;\n                length_insertions2 = 0;\n                length_deletions2 = 0;\n                lastequality = null;\n                changes = true;\n            }\n        }\n        pointer++;\n    }\n\n    // Normalize the diff.\n    if (changes) {\n        this.diff_cleanupMerge(diffs);\n    }\n    this.diff_cleanupSemanticLossless(diffs);\n\n    // Find any overlaps between deletions and insertions.\n    // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n    //   -> <del>abc</del>xxx<ins>def</ins>\n    // e.g: <del>xxxabc</del><ins>defxxx</ins>\n    //   -> <ins>def</ins>xxx<del>abc</del>\n    // Only extract an overlap if it is as big as the edit ahead or behind it.\n    pointer = 1;\n    while (pointer < diffs.length) {\n        if (diffs[pointer - 1][0] == DIFF_DELETE &&\n            diffs[pointer][0] == DIFF_INSERT) {\n            var deletion = diffs[pointer - 1][1];\n            var insertion = diffs[pointer][1];\n            var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n            var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n            if (overlap_length1 >= overlap_length2) {\n                if (overlap_length1 >= deletion.length / 2 ||\n                    overlap_length1 >= insertion.length / 2) {\n                    // Overlap found.  Insert an equality and trim the surrounding edits.\n                    diffs.splice(pointer, 0,\n                        [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\n                    diffs[pointer - 1][1] =\n                        deletion.substring(0, deletion.length - overlap_length1);\n                    diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n                    pointer++;\n                }\n            } else {\n                if (overlap_length2 >= deletion.length / 2 ||\n                    overlap_length2 >= insertion.length / 2) {\n                    // Reverse overlap found.\n                    // Insert an equality and swap and trim the surrounding edits.\n                    diffs.splice(pointer, 0,\n                        [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\n                    diffs[pointer - 1][0] = DIFF_INSERT;\n                    diffs[pointer - 1][1] =\n                        insertion.substring(0, insertion.length - overlap_length2);\n                    diffs[pointer + 1][0] = DIFF_DELETE;\n                    diffs[pointer + 1][1] =\n                        deletion.substring(overlap_length2);\n                    pointer++;\n                }\n            }\n            pointer++;\n        }\n        pointer++;\n    }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n    /**\n     * Given two strings, compute a score representing whether the internal\n     * boundary falls on logical boundaries.\n     * Scores range from 6 (best) to 0 (worst).\n     * Closure, but does not reference any external variables.\n     * @param {string} one First string.\n     * @param {string} two Second string.\n     * @return {number} The score.\n     * @private\n     */\n    function diff_cleanupSemanticScore_(one, two) {\n        if (!one || !two) {\n            // Edges are the best.\n            return 6;\n        }\n\n        // Each port of this function behaves slightly differently due to\n        // subtle differences in each language's definition of things like\n        // 'whitespace'.  Since this function's purpose is largely cosmetic,\n        // the choice has been made to use each language's native features\n        // rather than force total conformity.\n        var char1 = one.charAt(one.length - 1);\n        var char2 = two.charAt(0);\n        var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n        var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n        var whitespace1 = nonAlphaNumeric1 &&\n            char1.match(diff_match_patch.whitespaceRegex_);\n        var whitespace2 = nonAlphaNumeric2 &&\n            char2.match(diff_match_patch.whitespaceRegex_);\n        var lineBreak1 = whitespace1 &&\n            char1.match(diff_match_patch.linebreakRegex_);\n        var lineBreak2 = whitespace2 &&\n            char2.match(diff_match_patch.linebreakRegex_);\n        var blankLine1 = lineBreak1 &&\n            one.match(diff_match_patch.blanklineEndRegex_);\n        var blankLine2 = lineBreak2 &&\n            two.match(diff_match_patch.blanklineStartRegex_);\n\n        if (blankLine1 || blankLine2) {\n            // Five points for blank lines.\n            return 5;\n        } else if (lineBreak1 || lineBreak2) {\n            // Four points for line breaks.\n            return 4;\n        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n            // Three points for end of sentences.\n            return 3;\n        } else if (whitespace1 || whitespace2) {\n            // Two points for whitespace.\n            return 2;\n        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n            // One point for non-alphanumeric.\n            return 1;\n        }\n        return 0;\n    }\n\n    var pointer = 1;\n    // Intentionally ignore the first and last element (don't need checking).\n    while (pointer < diffs.length - 1) {\n        if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n            diffs[pointer + 1][0] == DIFF_EQUAL) {\n            // This is a single edit surrounded by equalities.\n            var equality1 = diffs[pointer - 1][1];\n            var edit = diffs[pointer][1];\n            var equality2 = diffs[pointer + 1][1];\n\n            // First, shift the edit as far left as possible.\n            var commonOffset = this.diff_commonSuffix(equality1, edit);\n            if (commonOffset) {\n                var commonString = edit.substring(edit.length - commonOffset);\n                equality1 = equality1.substring(0, equality1.length - commonOffset);\n                edit = commonString + edit.substring(0, edit.length - commonOffset);\n                equality2 = commonString + equality2;\n            }\n\n            // Second, step character by character right, looking for the best fit.\n            var bestEquality1 = equality1;\n            var bestEdit = edit;\n            var bestEquality2 = equality2;\n            var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n                diff_cleanupSemanticScore_(edit, equality2);\n            while (edit.charAt(0) === equality2.charAt(0)) {\n                equality1 += edit.charAt(0);\n                edit = edit.substring(1) + equality2.charAt(0);\n                equality2 = equality2.substring(1);\n                var score = diff_cleanupSemanticScore_(equality1, edit) +\n                    diff_cleanupSemanticScore_(edit, equality2);\n                // The >= encourages trailing rather than leading whitespace on edits.\n                if (score >= bestScore) {\n                    bestScore = score;\n                    bestEquality1 = equality1;\n                    bestEdit = edit;\n                    bestEquality2 = equality2;\n                }\n            }\n\n            if (diffs[pointer - 1][1] != bestEquality1) {\n                // We have an improvement, save it back to the diff.\n                if (bestEquality1) {\n                    diffs[pointer - 1][1] = bestEquality1;\n                } else {\n                    diffs.splice(pointer - 1, 1);\n                    pointer--;\n                }\n                diffs[pointer][1] = bestEdit;\n                if (bestEquality2) {\n                    diffs[pointer + 1][1] = bestEquality2;\n                } else {\n                    diffs.splice(pointer + 1, 1);\n                    pointer--;\n                }\n            }\n        }\n        pointer++;\n    }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n    var changes = false;\n    var equalities = [];  // Stack of indices where equalities are found.\n    var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n    /** @type {?string} */\n    var lastequality = null;\n    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n    var pointer = 0;  // Index of current position.\n    // Is there an insertion operation before the last equality.\n    var pre_ins = false;\n    // Is there a deletion operation before the last equality.\n    var pre_del = false;\n    // Is there an insertion operation after the last equality.\n    var post_ins = false;\n    // Is there a deletion operation after the last equality.\n    var post_del = false;\n    while (pointer < diffs.length) {\n        if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n            if (diffs[pointer][1].length < this.Diff_EditCost &&\n                (post_ins || post_del)) {\n                // Candidate found.\n                equalities[equalitiesLength++] = pointer;\n                pre_ins = post_ins;\n                pre_del = post_del;\n                lastequality = diffs[pointer][1];\n            } else {\n                // Not a candidate, and can never become one.\n                equalitiesLength = 0;\n                lastequality = null;\n            }\n            post_ins = post_del = false;\n        } else {  // An insertion or deletion.\n            if (diffs[pointer][0] == DIFF_DELETE) {\n                post_del = true;\n            } else {\n                post_ins = true;\n            }\n            /*\n             * Five types to be split:\n             * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n             * <ins>A</ins>X<ins>C</ins><del>D</del>\n             * <ins>A</ins><del>B</del>X<ins>C</ins>\n             * <ins>A</del>X<ins>C</ins><del>D</del>\n             * <ins>A</ins><del>B</del>X<del>C</del>\n             */\n            if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\n                ((lastequality.length < this.Diff_EditCost / 2) &&\n                    (pre_ins + pre_del + post_ins + post_del) == 3))) {\n                // Duplicate record.\n                diffs.splice(equalities[equalitiesLength - 1], 0,\n                    [DIFF_DELETE, lastequality]);\n                // Change second copy to insert.\n                diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n                equalitiesLength--;  // Throw away the equality we just deleted;\n                lastequality = null;\n                if (pre_ins && pre_del) {\n                    // No changes made which could affect previous entry, keep going.\n                    post_ins = post_del = true;\n                    equalitiesLength = 0;\n                } else {\n                    equalitiesLength--;  // Throw away the previous equality.\n                    pointer = equalitiesLength > 0 ?\n                        equalities[equalitiesLength - 1] : -1;\n                    post_ins = post_del = false;\n                }\n                changes = true;\n            }\n        }\n        pointer++;\n    }\n\n    if (changes) {\n        this.diff_cleanupMerge(diffs);\n    }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n    diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n    var pointer = 0;\n    var count_delete = 0;\n    var count_insert = 0;\n    var text_delete = '';\n    var text_insert = '';\n    var commonlength;\n    while (pointer < diffs.length) {\n        switch (diffs[pointer][0]) {\n            case DIFF_INSERT:\n                count_insert++;\n                text_insert += diffs[pointer][1];\n                pointer++;\n                break;\n            case DIFF_DELETE:\n                count_delete++;\n                text_delete += diffs[pointer][1];\n                pointer++;\n                break;\n            case DIFF_EQUAL:\n                // Upon reaching an equality, check for prior redundancies.\n                if (count_delete + count_insert > 1) {\n                    if (count_delete !== 0 && count_insert !== 0) {\n                        // Factor out any common prefixies.\n                        commonlength = this.diff_commonPrefix(text_insert, text_delete);\n                        if (commonlength !== 0) {\n                            if ((pointer - count_delete - count_insert) > 0 &&\n                                diffs[pointer - count_delete - count_insert - 1][0] ==\n                                DIFF_EQUAL) {\n                                diffs[pointer - count_delete - count_insert - 1][1] +=\n                                    text_insert.substring(0, commonlength);\n                            } else {\n                                diffs.splice(0, 0, [DIFF_EQUAL,\n                                    text_insert.substring(0, commonlength)]);\n                                pointer++;\n                            }\n                            text_insert = text_insert.substring(commonlength);\n                            text_delete = text_delete.substring(commonlength);\n                        }\n                        // Factor out any common suffixies.\n                        commonlength = this.diff_commonSuffix(text_insert, text_delete);\n                        if (commonlength !== 0) {\n                            diffs[pointer][1] = text_insert.substring(text_insert.length -\n                                commonlength) + diffs[pointer][1];\n                            text_insert = text_insert.substring(0, text_insert.length -\n                                commonlength);\n                            text_delete = text_delete.substring(0, text_delete.length -\n                                commonlength);\n                        }\n                    }\n                    // Delete the offending records and add the merged ones.\n                    if (count_delete === 0) {\n                        diffs.splice(pointer - count_insert,\n                            count_delete + count_insert, [DIFF_INSERT, text_insert]);\n                    } else if (count_insert === 0) {\n                        diffs.splice(pointer - count_delete,\n                            count_delete + count_insert, [DIFF_DELETE, text_delete]);\n                    } else {\n                        diffs.splice(pointer - count_delete - count_insert,\n                            count_delete + count_insert, [DIFF_DELETE, text_delete],\n                            [DIFF_INSERT, text_insert]);\n                    }\n                    pointer = pointer - count_delete - count_insert +\n                        (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n                } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n                    // Merge this equality with the previous one.\n                    diffs[pointer - 1][1] += diffs[pointer][1];\n                    diffs.splice(pointer, 1);\n                } else {\n                    pointer++;\n                }\n                count_insert = 0;\n                count_delete = 0;\n                text_delete = '';\n                text_insert = '';\n                break;\n        }\n    }\n    if (diffs[diffs.length - 1][1] === '') {\n        diffs.pop();  // Remove the dummy entry at the end.\n    }\n\n    // Second pass: look for single edits surrounded on both sides by equalities\n    // which can be shifted sideways to eliminate an equality.\n    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n    var changes = false;\n    pointer = 1;\n    // Intentionally ignore the first and last element (don't need checking).\n    while (pointer < diffs.length - 1) {\n        if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n            diffs[pointer + 1][0] == DIFF_EQUAL) {\n            // This is a single edit surrounded by equalities.\n            if (diffs[pointer][1].substring(diffs[pointer][1].length -\n                diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n                // Shift the edit over the previous equality.\n                diffs[pointer][1] = diffs[pointer - 1][1] +\n                    diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                        diffs[pointer - 1][1].length);\n                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n                diffs.splice(pointer - 1, 1);\n                changes = true;\n            } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n                diffs[pointer + 1][1]) {\n                // Shift the edit over the next equality.\n                diffs[pointer - 1][1] += diffs[pointer + 1][1];\n                diffs[pointer][1] =\n                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n                    diffs[pointer + 1][1];\n                diffs.splice(pointer + 1, 1);\n                changes = true;\n            }\n        }\n        pointer++;\n    }\n    // If shifts were made, the diff needs reordering and another shift sweep.\n    if (changes) {\n        this.diff_cleanupMerge(diffs);\n    }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n    var chars1 = 0;\n    var chars2 = 0;\n    var last_chars1 = 0;\n    var last_chars2 = 0;\n    var x;\n    for (x = 0; x < diffs.length; x++) {\n        if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n            chars1 += diffs[x][1].length;\n        }\n        if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n            chars2 += diffs[x][1].length;\n        }\n        if (chars1 > loc) {  // Overshot the location.\n            break;\n        }\n        last_chars1 = chars1;\n        last_chars2 = chars2;\n    }\n    // Was the location was deleted?\n    if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n        return last_chars2;\n    }\n    // Add the remaining character length.\n    return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n    var html = [];\n    var pattern_amp = /&/g;\n    var pattern_lt = /</g;\n    var pattern_gt = />/g;\n    var pattern_para = /\\n/g;\n    for (var x = 0; x < diffs.length; x++) {\n        var op = diffs[x][0];    // Operation (insert, delete, equal)\n        var data = diffs[x][1];  // Text of change.\n        var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n            .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n        switch (op) {\n            case DIFF_INSERT:\n                html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n                break;\n            case DIFF_DELETE:\n                html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n                break;\n            case DIFF_EQUAL:\n                html[x] = '<span>' + text + '</span>';\n                break;\n        }\n    }\n    return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\n    var text = [];\n    for (var x = 0; x < diffs.length; x++) {\n        if (diffs[x][0] !== DIFF_INSERT) {\n            text[x] = diffs[x][1];\n        }\n    }\n    return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\n    var text = [];\n    for (var x = 0; x < diffs.length; x++) {\n        if (diffs[x][0] !== DIFF_DELETE) {\n            text[x] = diffs[x][1];\n        }\n    }\n    return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n    var levenshtein = 0;\n    var insertions = 0;\n    var deletions = 0;\n    for (var x = 0; x < diffs.length; x++) {\n        var op = diffs[x][0];\n        var data = diffs[x][1];\n        switch (op) {\n            case DIFF_INSERT:\n                insertions += data.length;\n                break;\n            case DIFF_DELETE:\n                deletions += data.length;\n                break;\n            case DIFF_EQUAL:\n                // A deletion and an insertion is one substitution.\n                levenshtein += Math.max(insertions, deletions);\n                insertions = 0;\n                deletions = 0;\n                break;\n        }\n    }\n    levenshtein += Math.max(insertions, deletions);\n    return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\n    var text = [];\n    for (var x = 0; x < diffs.length; x++) {\n        switch (diffs[x][0]) {\n            case DIFF_INSERT:\n                text[x] = '+' + encodeURI(diffs[x][1]);\n                break;\n            case DIFF_DELETE:\n                text[x] = '-' + diffs[x][1].length;\n                break;\n            case DIFF_EQUAL:\n                text[x] = '=' + diffs[x][1].length;\n                break;\n        }\n    }\n    return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n    var diffs = [];\n    var diffsLength = 0;  // Keeping our own length var is faster in JS.\n    var pointer = 0;  // Cursor in text1\n    var tokens = delta.split(/\\t/g);\n    for (var x = 0; x < tokens.length; x++) {\n        // Each token begins with a one character parameter which specifies the\n        // operation of this token (delete, insert, equality).\n        var param = tokens[x].substring(1);\n        switch (tokens[x].charAt(0)) {\n            case '+':\n                try {\n                    diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\n                } catch (ex) {\n                    // Malformed URI sequence.\n                    throw new Error('Illegal escape in diff_fromDelta: ' + param);\n                }\n                break;\n            case '-':\n            // Fall through.\n            case '=':\n                var n = parseInt(param, 10);\n                if (isNaN(n) || n < 0) {\n                    throw new Error('Invalid number in diff_fromDelta: ' + param);\n                }\n                var text = text1.substring(pointer, pointer += n);\n                if (tokens[x].charAt(0) == '=') {\n                    diffs[diffsLength++] = [DIFF_EQUAL, text];\n                } else {\n                    diffs[diffsLength++] = [DIFF_DELETE, text];\n                }\n                break;\n            default:\n                // Blank tokens are ok (from a trailing \\t).\n                // Anything else is an error.\n                if (tokens[x]) {\n                    throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                        tokens[x]);\n                }\n        }\n    }\n    if (pointer != text1.length) {\n        throw new Error('Delta length (' + pointer +\n            ') does not equal source text length (' + text1.length + ').');\n    }\n    return diffs;\n};\n\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n    // Check for null inputs.\n    if (text == null || pattern == null || loc == null) {\n        throw new Error('Null input. (match_main)');\n    }\n\n    loc = Math.max(0, Math.min(loc, text.length));\n    if (text == pattern) {\n        // Shortcut (potentially not guaranteed by the algorithm)\n        return 0;\n    } else if (!text.length) {\n        // Nothing to match.\n        return -1;\n    } else if (text.substring(loc, loc + pattern.length) == pattern) {\n        // Perfect match at the perfect spot!  (Includes case of null pattern)\n        return loc;\n    } else {\n        // Do a fuzzy compare.\n        return this.match_bitap_(text, pattern, loc);\n    }\n};\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n    if (pattern.length > this.Match_MaxBits) {\n        throw new Error('Pattern too long for this browser.');\n    }\n\n    // Initialise the alphabet.\n    var s = this.match_alphabet_(pattern);\n\n    var dmp = this;  // 'this' becomes 'window' in a closure.\n\n    /**\n     * Compute and return the score for a match with e errors and x location.\n     * Accesses loc and pattern through being a closure.\n     * @param {number} e Number of errors in match.\n     * @param {number} x Location of match.\n     * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n     * @private\n     */\n    function match_bitapScore_(e, x) {\n        var accuracy = e / pattern.length;\n        var proximity = Math.abs(loc - x);\n        if (!dmp.Match_Distance) {\n            // Dodge divide by zero error.\n            return proximity ? 1.0 : accuracy;\n        }\n        return accuracy + (proximity / dmp.Match_Distance);\n    }\n\n    // Highest score beyond which we give up.\n    var score_threshold = this.Match_Threshold;\n    // Is there a nearby exact match? (speedup)\n    var best_loc = text.indexOf(pattern, loc);\n    if (best_loc != -1) {\n        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n        // What about in the other direction? (speedup)\n        best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n        if (best_loc != -1) {\n            score_threshold =\n                Math.min(match_bitapScore_(0, best_loc), score_threshold);\n        }\n    }\n\n    // Initialise the bit arrays.\n    var matchmask = 1 << (pattern.length - 1);\n    best_loc = -1;\n\n    var bin_min, bin_mid;\n    var bin_max = pattern.length + text.length;\n    var last_rd;\n    for (var d = 0; d < pattern.length; d++) {\n        // Scan for the best match; each iteration allows for one more error.\n        // Run a binary search to determine how far from 'loc' we can stray at this\n        // error level.\n        bin_min = 0;\n        bin_mid = bin_max;\n        while (bin_min < bin_mid) {\n            if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n                bin_min = bin_mid;\n            } else {\n                bin_max = bin_mid;\n            }\n            bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n        }\n        // Use the result from this iteration as the maximum for the next.\n        bin_max = bin_mid;\n        var start = Math.max(1, loc - bin_mid + 1);\n        var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n        var rd = Array(finish + 2);\n        rd[finish + 1] = (1 << d) - 1;\n        for (var j = finish; j >= start; j--) {\n            // The alphabet (s) is a sparse hash, so the following line generates\n            // warnings.\n            var charMatch = s[text.charAt(j - 1)];\n            if (d === 0) {  // First pass: exact match.\n                rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n            } else {  // Subsequent passes: fuzzy match.\n                rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                    (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                    last_rd[j + 1];\n            }\n            if (rd[j] & matchmask) {\n                var score = match_bitapScore_(d, j - 1);\n                // This match will almost certainly be better than any existing match.\n                // But check anyway.\n                if (score <= score_threshold) {\n                    // Told you so.\n                    score_threshold = score;\n                    best_loc = j - 1;\n                    if (best_loc > loc) {\n                        // When passing loc, don't exceed our current distance from loc.\n                        start = Math.max(1, 2 * loc - best_loc);\n                    } else {\n                        // Already passed loc, downhill from here on in.\n                        break;\n                    }\n                }\n            }\n        }\n        // No hope for a (better) match at greater error levels.\n        if (match_bitapScore_(d + 1, loc) > score_threshold) {\n            break;\n        }\n        last_rd = rd;\n    }\n    return best_loc;\n};\n\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n    var s = {};\n    for (var i = 0; i < pattern.length; i++) {\n        s[pattern.charAt(i)] = 0;\n    }\n    for (var i = 0; i < pattern.length; i++) {\n        s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n    }\n    return s;\n};\n\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n    if (text.length == 0) {\n        return;\n    }\n    var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n    var padding = 0;\n\n    // Look for the first and last matches of pattern in text.  If two different\n    // matches are found, increase the pattern length.\n    while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n    pattern.length < this.Match_MaxBits - this.Patch_Margin -\n    this.Patch_Margin) {\n        padding += this.Patch_Margin;\n        pattern = text.substring(patch.start2 - padding,\n            patch.start2 + patch.length1 + padding);\n    }\n    // Add one chunk for good luck.\n    padding += this.Patch_Margin;\n\n    // Add the prefix.\n    var prefix = text.substring(patch.start2 - padding, patch.start2);\n    if (prefix) {\n        patch.diffs.unshift([DIFF_EQUAL, prefix]);\n    }\n    // Add the suffix.\n    var suffix = text.substring(patch.start2 + patch.length1,\n        patch.start2 + patch.length1 + padding);\n    if (suffix) {\n        patch.diffs.push([DIFF_EQUAL, suffix]);\n    }\n\n    // Roll back the start points.\n    patch.start1 -= prefix.length;\n    patch.start2 -= prefix.length;\n    // Extend the lengths.\n    patch.length1 += prefix.length + suffix.length;\n    patch.length2 += prefix.length + suffix.length;\n};\n\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n    var text1, diffs;\n    if (typeof a == 'string' && typeof opt_b == 'string' &&\n        typeof opt_c == 'undefined') {\n        // Method 1: text1, text2\n        // Compute diffs from text1 and text2.\n        text1 = /** @type {string} */(a);\n        diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n        if (diffs.length > 2) {\n            this.diff_cleanupSemantic(diffs);\n            this.diff_cleanupEfficiency(diffs);\n        }\n    } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n        typeof opt_c == 'undefined') {\n        // Method 2: diffs\n        // Compute text1 from diffs.\n        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n        text1 = this.diff_text1(diffs);\n    } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n        typeof opt_c == 'undefined') {\n        // Method 3: text1, diffs\n        text1 = /** @type {string} */(a);\n        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n    } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n        opt_c && typeof opt_c == 'object') {\n        // Method 4: text1, text2, diffs\n        // text2 is not used.\n        text1 = /** @type {string} */(a);\n        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n    } else {\n        throw new Error('Unknown call format to patch_make.');\n    }\n\n    if (diffs.length === 0) {\n        return [];  // Get rid of the null case.\n    }\n    var patches = [];\n    var patch = new diff_match_patch.patch_obj();\n    var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n    var char_count1 = 0;  // Number of characters into the text1 string.\n    var char_count2 = 0;  // Number of characters into the text2 string.\n    // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n    // text2 (postpatch_text).  We recreate the patches one by one to determine\n    // context info.\n    var prepatch_text = text1;\n    var postpatch_text = text1;\n    for (var x = 0; x < diffs.length; x++) {\n        var diff_type = diffs[x][0];\n        var diff_text = diffs[x][1];\n\n        if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n            // A new patch starts here.\n            patch.start1 = char_count1;\n            patch.start2 = char_count2;\n        }\n\n        switch (diff_type) {\n            case DIFF_INSERT:\n                patch.diffs[patchDiffLength++] = diffs[x];\n                patch.length2 += diff_text.length;\n                postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                    postpatch_text.substring(char_count2);\n                break;\n            case DIFF_DELETE:\n                patch.length1 += diff_text.length;\n                patch.diffs[patchDiffLength++] = diffs[x];\n                postpatch_text = postpatch_text.substring(0, char_count2) +\n                    postpatch_text.substring(char_count2 +\n                        diff_text.length);\n                break;\n            case DIFF_EQUAL:\n                if (diff_text.length <= 2 * this.Patch_Margin &&\n                    patchDiffLength && diffs.length != x + 1) {\n                    // Small equality inside a patch.\n                    patch.diffs[patchDiffLength++] = diffs[x];\n                    patch.length1 += diff_text.length;\n                    patch.length2 += diff_text.length;\n                } else if (diff_text.length >= 2 * this.Patch_Margin) {\n                    // Time for a new patch.\n                    if (patchDiffLength) {\n                        this.patch_addContext_(patch, prepatch_text);\n                        patches.push(patch);\n                        patch = new diff_match_patch.patch_obj();\n                        patchDiffLength = 0;\n                        // Unlike Unidiff, our patch lists have a rolling context.\n                        // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n                        // Update prepatch text & pos to reflect the application of the\n                        // just completed patch.\n                        prepatch_text = postpatch_text;\n                        char_count1 = char_count2;\n                    }\n                }\n                break;\n        }\n\n        // Update the current character count.\n        if (diff_type !== DIFF_INSERT) {\n            char_count1 += diff_text.length;\n        }\n        if (diff_type !== DIFF_DELETE) {\n            char_count2 += diff_text.length;\n        }\n    }\n    // Pick up the leftover patch if not empty.\n    if (patchDiffLength) {\n        this.patch_addContext_(patch, prepatch_text);\n        patches.push(patch);\n    }\n\n    return patches;\n};\n\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\n    // Making deep copies is hard in JavaScript.\n    var patchesCopy = [];\n    for (var x = 0; x < patches.length; x++) {\n        var patch = patches[x];\n        var patchCopy = new diff_match_patch.patch_obj();\n        patchCopy.diffs = [];\n        for (var y = 0; y < patch.diffs.length; y++) {\n            patchCopy.diffs[y] = patch.diffs[y].slice();\n        }\n        patchCopy.start1 = patch.start1;\n        patchCopy.start2 = patch.start2;\n        patchCopy.length1 = patch.length1;\n        patchCopy.length2 = patch.length2;\n        patchesCopy[x] = patchCopy;\n    }\n    return patchesCopy;\n};\n\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\n    if (patches.length == 0) {\n        return [text, []];\n    }\n\n    // Deep copy the patches so that no changes are made to originals.\n    patches = this.patch_deepCopy(patches);\n\n    var nullPadding = this.patch_addPadding(patches);\n    text = nullPadding + text + nullPadding;\n\n    this.patch_splitMax(patches);\n    // delta keeps track of the offset between the expected and actual location\n    // of the previous patch.  If there are patches expected at positions 10 and\n    // 20, but the first patch was found at 12, delta is 2 and the second patch\n    // has an effective expected position of 22.\n    var delta = 0;\n    var results = [];\n    for (var x = 0; x < patches.length; x++) {\n        var expected_loc = patches[x].start2 + delta;\n        var text1 = this.diff_text1(patches[x].diffs);\n        var start_loc;\n        var end_loc = -1;\n        if (text1.length > this.Match_MaxBits) {\n            // patch_splitMax will only provide an oversized pattern in the case of\n            // a monster delete.\n            start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                expected_loc);\n            if (start_loc != -1) {\n                end_loc = this.match_main(text,\n                    text1.substring(text1.length - this.Match_MaxBits),\n                    expected_loc + text1.length - this.Match_MaxBits);\n                if (end_loc == -1 || start_loc >= end_loc) {\n                    // Can't find valid trailing context.  Drop this patch.\n                    start_loc = -1;\n                }\n            }\n        } else {\n            start_loc = this.match_main(text, text1, expected_loc);\n        }\n        if (start_loc == -1) {\n            // No match found.  :(\n            results[x] = false;\n            // Subtract the delta for this failed patch from subsequent patches.\n            delta -= patches[x].length2 - patches[x].length1;\n        } else {\n            // Found a match.  :)\n            results[x] = true;\n            delta = start_loc - expected_loc;\n            var text2;\n            if (end_loc == -1) {\n                text2 = text.substring(start_loc, start_loc + text1.length);\n            } else {\n                text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n            }\n            if (text1 == text2) {\n                // Perfect match, just shove the replacement text in.\n                text = text.substring(0, start_loc) +\n                    this.diff_text2(patches[x].diffs) +\n                    text.substring(start_loc + text1.length);\n            } else {\n                // Imperfect match.  Run a diff to get a framework of equivalent\n                // indices.\n                var diffs = this.diff_main(text1, text2, false);\n                if (text1.length > this.Match_MaxBits &&\n                    this.diff_levenshtein(diffs) / text1.length >\n                    this.Patch_DeleteThreshold) {\n                    // The end points match, but the content is unacceptably bad.\n                    results[x] = false;\n                } else {\n                    this.diff_cleanupSemanticLossless(diffs);\n                    var index1 = 0;\n                    var index2;\n                    for (var y = 0; y < patches[x].diffs.length; y++) {\n                        var mod = patches[x].diffs[y];\n                        if (mod[0] !== DIFF_EQUAL) {\n                            index2 = this.diff_xIndex(diffs, index1);\n                        }\n                        if (mod[0] === DIFF_INSERT) {  // Insertion\n                            text = text.substring(0, start_loc + index2) + mod[1] +\n                                text.substring(start_loc + index2);\n                        } else if (mod[0] === DIFF_DELETE) {  // Deletion\n                            text = text.substring(0, start_loc + index2) +\n                                text.substring(start_loc + this.diff_xIndex(diffs,\n                                    index1 + mod[1].length));\n                        }\n                        if (mod[0] !== DIFF_DELETE) {\n                            index1 += mod[1].length;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // Strip the padding off.\n    text = text.substring(nullPadding.length, text.length - nullPadding.length);\n    return [text, results];\n};\n\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\n    var paddingLength = this.Patch_Margin;\n    var nullPadding = '';\n    for (var x = 1; x <= paddingLength; x++) {\n        nullPadding += String.fromCharCode(x);\n    }\n\n    // Bump all the patches forward.\n    for (var x = 0; x < patches.length; x++) {\n        patches[x].start1 += paddingLength;\n        patches[x].start2 += paddingLength;\n    }\n\n    // Add some padding on start of first diff.\n    var patch = patches[0];\n    var diffs = patch.diffs;\n    if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n        // Add nullPadding equality.\n        diffs.unshift([DIFF_EQUAL, nullPadding]);\n        patch.start1 -= paddingLength;  // Should be 0.\n        patch.start2 -= paddingLength;  // Should be 0.\n        patch.length1 += paddingLength;\n        patch.length2 += paddingLength;\n    } else if (paddingLength > diffs[0][1].length) {\n        // Grow first equality.\n        var extraLength = paddingLength - diffs[0][1].length;\n        diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n        patch.start1 -= extraLength;\n        patch.start2 -= extraLength;\n        patch.length1 += extraLength;\n        patch.length2 += extraLength;\n    }\n\n    // Add some padding on end of last diff.\n    patch = patches[patches.length - 1];\n    diffs = patch.diffs;\n    if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n        // Add nullPadding equality.\n        diffs.push([DIFF_EQUAL, nullPadding]);\n        patch.length1 += paddingLength;\n        patch.length2 += paddingLength;\n    } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n        // Grow last equality.\n        var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n        patch.length1 += extraLength;\n        patch.length2 += extraLength;\n    }\n\n    return nullPadding;\n};\n\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\n    var patch_size = this.Match_MaxBits;\n    for (var x = 0; x < patches.length; x++) {\n        if (patches[x].length1 <= patch_size) {\n            continue;\n        }\n        var bigpatch = patches[x];\n        // Remove the big old patch.\n        patches.splice(x--, 1);\n        var start1 = bigpatch.start1;\n        var start2 = bigpatch.start2;\n        var precontext = '';\n        while (bigpatch.diffs.length !== 0) {\n            // Create one of several smaller patches.\n            var patch = new diff_match_patch.patch_obj();\n            var empty = true;\n            patch.start1 = start1 - precontext.length;\n            patch.start2 = start2 - precontext.length;\n            if (precontext !== '') {\n                patch.length1 = patch.length2 = precontext.length;\n                patch.diffs.push([DIFF_EQUAL, precontext]);\n            }\n            while (bigpatch.diffs.length !== 0 &&\n            patch.length1 < patch_size - this.Patch_Margin) {\n                var diff_type = bigpatch.diffs[0][0];\n                var diff_text = bigpatch.diffs[0][1];\n                if (diff_type === DIFF_INSERT) {\n                    // Insertions are harmless.\n                    patch.length2 += diff_text.length;\n                    start2 += diff_text.length;\n                    patch.diffs.push(bigpatch.diffs.shift());\n                    empty = false;\n                } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n                    patch.diffs[0][0] == DIFF_EQUAL &&\n                    diff_text.length > 2 * patch_size) {\n                    // This is a large deletion.  Let it pass in one chunk.\n                    patch.length1 += diff_text.length;\n                    start1 += diff_text.length;\n                    empty = false;\n                    patch.diffs.push([diff_type, diff_text]);\n                    bigpatch.diffs.shift();\n                } else {\n                    // Deletion or equality.  Only take as much as we can stomach.\n                    diff_text = diff_text.substring(0,\n                        patch_size - patch.length1 - this.Patch_Margin);\n                    patch.length1 += diff_text.length;\n                    start1 += diff_text.length;\n                    if (diff_type === DIFF_EQUAL) {\n                        patch.length2 += diff_text.length;\n                        start2 += diff_text.length;\n                    } else {\n                        empty = false;\n                    }\n                    patch.diffs.push([diff_type, diff_text]);\n                    if (diff_text == bigpatch.diffs[0][1]) {\n                        bigpatch.diffs.shift();\n                    } else {\n                        bigpatch.diffs[0][1] =\n                            bigpatch.diffs[0][1].substring(diff_text.length);\n                    }\n                }\n            }\n            // Compute the head context for the next patch.\n            precontext = this.diff_text2(patch.diffs);\n            precontext =\n                precontext.substring(precontext.length - this.Patch_Margin);\n            // Append the end context for this patch.\n            var postcontext = this.diff_text1(bigpatch.diffs)\n                .substring(0, this.Patch_Margin);\n            if (postcontext !== '') {\n                patch.length1 += postcontext.length;\n                patch.length2 += postcontext.length;\n                if (patch.diffs.length !== 0 &&\n                    patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n                    patch.diffs[patch.diffs.length - 1][1] += postcontext;\n                } else {\n                    patch.diffs.push([DIFF_EQUAL, postcontext]);\n                }\n            }\n            if (!empty) {\n                patches.splice(++x, 0, patch);\n            }\n        }\n    }\n};\n\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function(patches) {\n    var text = [];\n    for (var x = 0; x < patches.length; x++) {\n        text[x] = patches[x];\n    }\n    return text.join('');\n};\n\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function(textline) {\n    var patches = [];\n    if (!textline) {\n        return patches;\n    }\n    var text = textline.split('\\n');\n    var textPointer = 0;\n    var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n    while (textPointer < text.length) {\n        var m = text[textPointer].match(patchHeader);\n        if (!m) {\n            throw new Error('Invalid patch string: ' + text[textPointer]);\n        }\n        var patch = new diff_match_patch.patch_obj();\n        patches.push(patch);\n        patch.start1 = parseInt(m[1], 10);\n        if (m[2] === '') {\n            patch.start1--;\n            patch.length1 = 1;\n        } else if (m[2] == '0') {\n            patch.length1 = 0;\n        } else {\n            patch.start1--;\n            patch.length1 = parseInt(m[2], 10);\n        }\n\n        patch.start2 = parseInt(m[3], 10);\n        if (m[4] === '') {\n            patch.start2--;\n            patch.length2 = 1;\n        } else if (m[4] == '0') {\n            patch.length2 = 0;\n        } else {\n            patch.start2--;\n            patch.length2 = parseInt(m[4], 10);\n        }\n        textPointer++;\n\n        while (textPointer < text.length) {\n            var sign = text[textPointer].charAt(0);\n            try {\n                var line = decodeURI(text[textPointer].substring(1));\n            } catch (ex) {\n                // Malformed URI sequence.\n                throw new Error('Illegal escape in patch_fromText: ' + line);\n            }\n            if (sign == '-') {\n                // Deletion.\n                patch.diffs.push([DIFF_DELETE, line]);\n            } else if (sign == '+') {\n                // Insertion.\n                patch.diffs.push([DIFF_INSERT, line]);\n            } else if (sign == ' ') {\n                // Minor equality.\n                patch.diffs.push([DIFF_EQUAL, line]);\n            } else if (sign == '@') {\n                // Start of next patch.\n                break;\n            } else if (sign === '') {\n                // Blank line?  Whatever.\n            } else {\n                // WTF?\n                throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n            }\n            textPointer++;\n        }\n    }\n    return patches;\n};\n\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function() {\n    /** @type {!Array.<!diff_match_patch.Diff>} */\n    this.diffs = [];\n    /** @type {?number} */\n    this.start1 = null;\n    /** @type {?number} */\n    this.start2 = null;\n    /** @type {number} */\n    this.length1 = 0;\n    /** @type {number} */\n    this.length2 = 0;\n};\n\n\n/**\n * Emmulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indicies are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function() {\n    var coords1, coords2;\n    if (this.length1 === 0) {\n        coords1 = this.start1 + ',0';\n    } else if (this.length1 == 1) {\n        coords1 = this.start1 + 1;\n    } else {\n        coords1 = (this.start1 + 1) + ',' + this.length1;\n    }\n    if (this.length2 === 0) {\n        coords2 = this.start2 + ',0';\n    } else if (this.length2 == 1) {\n        coords2 = this.start2 + 1;\n    } else {\n        coords2 = (this.start2 + 1) + ',' + this.length2;\n    }\n    var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n    var op;\n    // Escape the body of the patch with %xx notation.\n    for (var x = 0; x < this.diffs.length; x++) {\n        switch (this.diffs[x][0]) {\n            case DIFF_INSERT:\n                op = '+';\n                break;\n            case DIFF_DELETE:\n                op = '-';\n                break;\n            case DIFF_EQUAL:\n                op = ' ';\n                break;\n        }\n        text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n    }\n    return text.join('').replace(/%20/g, ' ');\n};\n\n\n// Export these global variables so that they survive Google's JS compiler.\n// In a browser, 'this' will be 'window'.\n// Users of node.js should 'require' the uncompressed version since Google's\n// JS compiler may break the following exports for non-browser environments.\nthis['diff_match_patch'] = diff_match_patch;\nthis['DIFF_DELETE'] = DIFF_DELETE;\nthis['DIFF_INSERT'] = DIFF_INSERT;\nthis['DIFF_EQUAL'] = DIFF_EQUAL;\n\ndefine([\"mod_codescore/codemirrorlib\"],function(CodeMirror) {\n        \"use strict\";\n        var Pos = CodeMirror.Pos;\n        var svgNS = \"http://www.w3.org/2000/svg\";\n\n        function DiffView(mv, type) {\n            this.mv = mv;\n            this.type = type;\n            this.classes = type == \"left\"\n                ? {\n                    chunk: \"CodeMirror-merge-l-chunk\",\n                    start: \"CodeMirror-merge-l-chunk-start\",\n                    end: \"CodeMirror-merge-l-chunk-end\",\n                    insert: \"CodeMirror-merge-l-inserted\",\n                    del: \"CodeMirror-merge-l-deleted\",\n                    connect: \"CodeMirror-merge-l-connect\"\n                }\n                : {\n                    chunk: \"CodeMirror-merge-r-chunk\",\n                    start: \"CodeMirror-merge-r-chunk-start\",\n                    end: \"CodeMirror-merge-r-chunk-end\",\n                    insert: \"CodeMirror-merge-r-inserted\",\n                    del: \"CodeMirror-merge-r-deleted\",\n                    connect: \"CodeMirror-merge-r-connect\"\n                };\n        }\n\n        DiffView.prototype = {\n            constructor: DiffView,\n            init: function(pane, orig, options) {\n                this.edit = this.mv.edit;\n                ;(this.edit.state.diffViews || (this.edit.state.diffViews = [])).push(this);\n                this.orig = CodeMirror(pane, copyObj({\n                    value: orig,\n                    readOnly: !this.mv.options.allowEditingOriginals\n                }, copyObj(options)));\n                if (this.mv.options.connect == \"align\") {\n                    if (!this.edit.state.trackAlignable) this.edit.state.trackAlignable = new TrackAlignable(this.edit)\n                    this.orig.state.trackAlignable = new TrackAlignable(this.orig)\n                }\n                this.lockButton.title = this.edit.phrase(\"Toggle locked scrolling\");\n                this.lockButton.setAttribute(\"aria-label\", this.lockButton.title);\n\n                this.orig.state.diffViews = [this];\n                var classLocation = options.chunkClassLocation || \"background\";\n                if (Object.prototype.toString.call(classLocation) != \"[object Array]\") classLocation = [classLocation]\n                this.classes.classLocation = classLocation\n\n                this.diff = getDiff(asString(orig), asString(options.value), this.mv.options.ignoreWhitespace);\n                this.chunks = getChunks(this.diff);\n                this.diffOutOfDate = this.dealigned = false;\n                this.needsScrollSync = null\n\n                this.showDifferences = options.showDifferences !== false;\n            },\n            registerEvents: function(otherDv) {\n                this.forceUpdate = registerUpdate(this);\n                setScrollLock(this, true, false);\n                registerScroll(this, otherDv);\n            },\n            setShowDifferences: function(val) {\n                val = val !== false;\n                if (val != this.showDifferences) {\n                    this.showDifferences = val;\n                    this.forceUpdate(\"full\");\n                }\n            }\n        };\n\n        function ensureDiff(dv) {\n            if (dv.diffOutOfDate) {\n                dv.diff = getDiff(dv.orig.getValue(), dv.edit.getValue(), dv.mv.options.ignoreWhitespace);\n                dv.chunks = getChunks(dv.diff);\n                dv.diffOutOfDate = false;\n                CodeMirror.signal(dv.edit, \"updateDiff\", dv.diff);\n            }\n        }\n\n        var updating = false;\n\n        function registerUpdate(dv) {\n            var edit = {from: 0, to: 0, marked: []};\n            var orig = {from: 0, to: 0, marked: []};\n            var debounceChange,\n                updatingFast = false;\n\n            function update(mode) {\n                updating = true;\n                updatingFast = false;\n                if (mode == \"full\") {\n                    if (dv.svg) clear(dv.svg);\n                    if (dv.copyButtons) clear(dv.copyButtons);\n                    clearMarks(dv.edit, edit.marked, dv.classes);\n                    clearMarks(dv.orig, orig.marked, dv.classes);\n                    edit.from = edit.to = orig.from = orig.to = 0;\n                }\n                ensureDiff(dv);\n                if (dv.showDifferences) {\n                    updateMarks(dv.edit, dv.diff, edit, DIFF_INSERT, dv.classes);\n                    updateMarks(dv.orig, dv.diff, orig, DIFF_DELETE, dv.classes);\n                }\n\n                if (dv.mv.options.connect == \"align\")\n                    alignChunks(dv);\n                makeConnections(dv);\n                if (dv.needsScrollSync != null) syncScroll(dv, dv.needsScrollSync)\n\n                updating = false;\n            }\n\n            function setDealign(fast) {\n                if (updating) return;\n                dv.dealigned = true;\n                set(fast);\n            }\n\n            function set(fast) {\n                if (updating || updatingFast) return;\n                clearTimeout(debounceChange);\n                if (fast === true) updatingFast = true;\n                debounceChange = setTimeout(update, fast === true ? 20 : 250);\n            }\n\n            function change(_cm, change) {\n                if (!dv.diffOutOfDate) {\n                    dv.diffOutOfDate = true;\n                    edit.from = edit.to = orig.from = orig.to = 0;\n                }\n                // Update faster when a line was added/removed\n                setDealign(change.text.length - 1 != change.to.line - change.from.line);\n            }\n\n            function swapDoc() {\n                dv.diffOutOfDate = true;\n                dv.dealigned = true;\n                update(\"full\");\n            }\n\n            dv.edit.on(\"change\", change);\n            dv.orig.on(\"change\", change);\n            dv.edit.on(\"swapDoc\", swapDoc);\n            dv.orig.on(\"swapDoc\", swapDoc);\n            if (dv.mv.options.connect == \"align\") {\n                CodeMirror.on(dv.edit.state.trackAlignable, \"realign\", setDealign)\n                CodeMirror.on(dv.orig.state.trackAlignable, \"realign\", setDealign)\n            }\n            dv.edit.on(\"viewportChange\", function() {\n                set(false);\n            });\n            dv.orig.on(\"viewportChange\", function() {\n                set(false);\n            });\n            update();\n            return update;\n        }\n\n        function registerScroll(dv, otherDv) {\n            dv.edit.on(\"scroll\", function() {\n                syncScroll(dv, true) && makeConnections(dv);\n            });\n            dv.orig.on(\"scroll\", function() {\n                syncScroll(dv, false) && makeConnections(dv);\n                if (otherDv) syncScroll(otherDv, true) && makeConnections(otherDv);\n            });\n        }\n\n        function syncScroll(dv, toOrig) {\n            // Change handler will do a refresh after a timeout when diff is out of date\n            if (dv.diffOutOfDate) {\n                if (dv.lockScroll && dv.needsScrollSync == null) dv.needsScrollSync = toOrig\n                return false\n            }\n            dv.needsScrollSync = null\n            if (!dv.lockScroll) return true;\n            var editor,\n                other,\n                now = +new Date;\n            if (toOrig) {\n                editor = dv.edit;\n                other = dv.orig;\n            } else {\n                editor = dv.orig;\n                other = dv.edit;\n            }\n            // Don't take action if the position of this editor was recently set\n            // (to prevent feedback loops)\n            if (editor.state.scrollSetBy == dv && (editor.state.scrollSetAt || 0) + 250 > now) return false;\n\n            var sInfo = editor.getScrollInfo();\n            if (dv.mv.options.connect == \"align\") {\n                targetPos = sInfo.top;\n            } else {\n                var halfScreen = .5 * sInfo.clientHeight,\n                    midY = sInfo.top + halfScreen;\n                var mid = editor.lineAtHeight(midY, \"local\");\n                var around = chunkBoundariesAround(dv.chunks, mid, toOrig);\n                var off = getOffsets(editor, toOrig ? around.edit : around.orig);\n                var offOther = getOffsets(other, toOrig ? around.orig : around.edit);\n                var ratio = (midY - off.top) / (off.bot - off.top);\n                var targetPos = (offOther.top - halfScreen) + ratio * (offOther.bot - offOther.top);\n\n                var botDist,\n                    mix;\n                // Some careful tweaking to make sure no space is left out of view\n                // when scrolling to top or bottom.\n                if (targetPos > sInfo.top && (mix = sInfo.top / halfScreen) < 1) {\n                    targetPos = targetPos * mix + sInfo.top * (1 - mix);\n                } else if ((botDist = sInfo.height - sInfo.clientHeight - sInfo.top) < halfScreen) {\n                    var otherInfo = other.getScrollInfo();\n                    var botDistOther = otherInfo.height - otherInfo.clientHeight - targetPos;\n                    if (botDistOther > botDist && (mix = botDist / halfScreen) < 1)\n                        targetPos = targetPos * mix + (otherInfo.height - otherInfo.clientHeight - botDist) * (1 - mix);\n                }\n            }\n\n            other.scrollTo(sInfo.left, targetPos);\n            other.state.scrollSetAt = now;\n            other.state.scrollSetBy = dv;\n            return true;\n        }\n\n        function getOffsets(editor, around) {\n            var bot = around.after;\n            if (bot == null) bot = editor.lastLine() + 1;\n            return {\n                top: editor.heightAtLine(around.before || 0, \"local\"),\n                bot: editor.heightAtLine(bot, \"local\")\n            };\n        }\n\n        function setScrollLock(dv, val, action) {\n            dv.lockScroll = val;\n            if (val && action != false) syncScroll(dv, DIFF_INSERT) && makeConnections(dv);\n            (val ? CodeMirror.addClass : CodeMirror.rmClass)(dv.lockButton, \"CodeMirror-merge-scrolllock-enabled\");\n        }\n\n        // Updating the marks for editor content\n\n        function removeClass(editor, line, classes) {\n            var locs = classes.classLocation\n            for (var i = 0; i < locs.length; i++) {\n                editor.removeLineClass(line, locs[i], classes.chunk);\n                editor.removeLineClass(line, locs[i], classes.start);\n                editor.removeLineClass(line, locs[i], classes.end);\n            }\n        }\n\n        function clearMarks(editor, arr, classes) {\n            for (var i = 0; i < arr.length; ++i) {\n                var mark = arr[i];\n                if (mark instanceof CodeMirror.TextMarker)\n                    mark.clear();\n                else if (mark.parent)\n                    removeClass(editor, mark, classes);\n            }\n            arr.length = 0;\n        }\n\n        // FIXME maybe add a margin around viewport to prevent too many updates\n        function updateMarks(editor, diff, state, type, classes) {\n            var vp = editor.getViewport();\n            editor.operation(function() {\n                if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n                    clearMarks(editor, state.marked, classes);\n                    markChanges(editor, diff, type, state.marked, vp.from, vp.to, classes);\n                    state.from = vp.from;\n                    state.to = vp.to;\n                } else {\n                    if (vp.from < state.from) {\n                        markChanges(editor, diff, type, state.marked, vp.from, state.from, classes);\n                        state.from = vp.from;\n                    }\n                    if (vp.to > state.to) {\n                        markChanges(editor, diff, type, state.marked, state.to, vp.to, classes);\n                        state.to = vp.to;\n                    }\n                }\n            });\n        }\n\n        function addClass(editor, lineNr, classes, main, start, end) {\n            var locs = classes.classLocation,\n                line = editor.getLineHandle(lineNr);\n            for (var i = 0; i < locs.length; i++) {\n                if (main) editor.addLineClass(line, locs[i], classes.chunk);\n                if (start) editor.addLineClass(line, locs[i], classes.start);\n                if (end) editor.addLineClass(line, locs[i], classes.end);\n            }\n            return line;\n        }\n\n        function markChanges(editor, diff, type, marks, from, to, classes) {\n            var pos = Pos(0, 0);\n            var top = Pos(from, 0),\n                bot = editor.clipPos(Pos(to - 1));\n            var cls = type == DIFF_DELETE ? classes.del : classes.insert;\n\n            function markChunk(start, end) {\n                var bfrom = Math.max(from, start),\n                    bto = Math.min(to, end);\n                for (var i = bfrom; i < bto; ++i)\n                    marks.push(addClass(editor, i, classes, true, i == start, i == end - 1));\n                // When the chunk is empty, make sure a horizontal line shows up\n                if (start == end && bfrom == end && bto == end) {\n                    if (bfrom)\n                        marks.push(addClass(editor, bfrom - 1, classes, false, false, true));\n                    else\n                        marks.push(addClass(editor, bfrom, classes, false, true, false));\n                }\n            }\n\n            var chunkStart = 0,\n                pending = false;\n            for (var i = 0; i < diff.length; ++i) {\n                var part = diff[i],\n                    tp = part[0],\n                    str = part[1];\n                if (tp == DIFF_EQUAL) {\n                    var cleanFrom = pos.line + (startOfLineClean(diff, i) ? 0 : 1);\n                    moveOver(pos, str);\n                    var cleanTo = pos.line + (endOfLineClean(diff, i) ? 1 : 0);\n                    if (cleanTo > cleanFrom) {\n                        if (pending) {\n                            markChunk(chunkStart, cleanFrom);\n                            pending = false\n                        }\n                        chunkStart = cleanTo;\n                    }\n                } else {\n                    pending = true\n                    if (tp == type) {\n                        var end = moveOver(pos, str, true);\n                        var a = posMax(top, pos),\n                            b = posMin(bot, end);\n                        if (!posEq(a, b))\n                            marks.push(editor.markText(a, b, {className: cls}));\n                        pos = end;\n                    }\n                }\n            }\n            if (pending) markChunk(chunkStart, pos.line + 1);\n        }\n\n        // Updating the gap between editor and original\n\n        function makeConnections(dv) {\n            if (!dv.showDifferences) return;\n\n            if (dv.svg) {\n                clear(dv.svg);\n                var w = dv.gap.offsetWidth;\n                attrs(dv.svg, \"width\", w, \"height\", dv.gap.offsetHeight);\n            }\n            if (dv.copyButtons) clear(dv.copyButtons);\n\n            var vpEdit = dv.edit.getViewport(),\n                vpOrig = dv.orig.getViewport();\n            var outerTop = dv.mv.wrap.getBoundingClientRect().top\n            var sTopEdit = outerTop - dv.edit.getScrollerElement().getBoundingClientRect().top + dv.edit.getScrollInfo().top\n            var sTopOrig = outerTop - dv.orig.getScrollerElement().getBoundingClientRect().top + dv.orig.getScrollInfo().top;\n            for (var i = 0; i < dv.chunks.length; i++) {\n                var ch = dv.chunks[i];\n                if (ch.editFrom <= vpEdit.to && ch.editTo >= vpEdit.from &&\n                    ch.origFrom <= vpOrig.to && ch.origTo >= vpOrig.from)\n                    drawConnectorsForChunk(dv, ch, sTopOrig, sTopEdit, w);\n            }\n        }\n\n        function getMatchingOrigLine(editLine, chunks) {\n            var editStart = 0,\n                origStart = 0;\n            for (var i = 0; i < chunks.length; i++) {\n                var chunk = chunks[i];\n                if (chunk.editTo > editLine && chunk.editFrom <= editLine) return null;\n                if (chunk.editFrom > editLine) break;\n                editStart = chunk.editTo;\n                origStart = chunk.origTo;\n            }\n            return origStart + (editLine - editStart);\n        }\n\n        // Combines information about chunks and widgets/markers to return\n        // an array of lines, in a single editor, that probably need to be\n        // aligned with their counterparts in the editor next to it.\n        function alignableFor(cm, chunks, isOrig) {\n            var tracker = cm.state.trackAlignable\n            var start = cm.firstLine(),\n                trackI = 0\n            var result = []\n            for (var i = 0; ; i++) {\n                var chunk = chunks[i]\n                var chunkStart = !chunk ? 1e9 : isOrig ? chunk.origFrom : chunk.editFrom\n                for (; trackI < tracker.alignable.length; trackI += 2) {\n                    var n = tracker.alignable[trackI] + 1\n                    if (n <= start) continue\n                    if (n <= chunkStart) result.push(n)\n                    else break\n                }\n                if (!chunk) break\n                result.push(start = isOrig ? chunk.origTo : chunk.editTo)\n            }\n            return result\n        }\n\n        // Given information about alignable lines in two editors, fill in\n        // the result (an array of three-element arrays) to reflect the\n        // lines that need to be aligned with each other.\n        function mergeAlignable(result, origAlignable, chunks, setIndex) {\n            var rI = 0,\n                origI = 0,\n                chunkI = 0,\n                diff = 0\n            outer: for (; ; rI++) {\n                var nextR = result[rI],\n                    nextO = origAlignable[origI]\n                if (!nextR && nextO == null) break\n\n                var rLine = nextR ? nextR[0] : 1e9,\n                    oLine = nextO == null ? 1e9 : nextO\n                while (chunkI < chunks.length) {\n                    var chunk = chunks[chunkI]\n                    if (chunk.origFrom <= oLine && chunk.origTo > oLine) {\n                        origI++\n                        rI--\n                        continue outer;\n                    }\n                    if (chunk.editTo > rLine) {\n                        if (chunk.editFrom <= rLine) continue outer;\n                        break\n                    }\n                    diff += (chunk.origTo - chunk.origFrom) - (chunk.editTo - chunk.editFrom)\n                    chunkI++\n                }\n                if (rLine == oLine - diff) {\n                    nextR[setIndex] = oLine\n                    origI++\n                } else if (rLine < oLine - diff) {\n                    nextR[setIndex] = rLine + diff\n                } else {\n                    var record = [oLine - diff, null, null]\n                    record[setIndex] = oLine\n                    result.splice(rI, 0, record)\n                    origI++\n                }\n            }\n        }\n\n        function findAlignedLines(dv, other) {\n            var alignable = alignableFor(dv.edit, dv.chunks, false),\n                result = []\n            if (other) for (var i = 0, j = 0; i < other.chunks.length; i++) {\n                var n = other.chunks[i].editTo\n                while (j < alignable.length && alignable[j] < n) j++\n                if (j == alignable.length || alignable[j] != n) alignable.splice(j++, 0, n)\n            }\n            for (var i = 0; i < alignable.length; i++)\n                result.push([alignable[i], null, null])\n\n            mergeAlignable(result, alignableFor(dv.orig, dv.chunks, true), dv.chunks, 1)\n            if (other)\n                mergeAlignable(result, alignableFor(other.orig, other.chunks, true), other.chunks, 2)\n\n            return result\n        }\n\n        function alignChunks(dv, force) {\n            if (!dv.dealigned && !force) return;\n            if (!dv.orig.curOp) return dv.orig.operation(function() {\n                alignChunks(dv, force);\n            });\n\n            dv.dealigned = false;\n            var other = dv.mv.left == dv ? dv.mv.right : dv.mv.left;\n            if (other) {\n                ensureDiff(other);\n                other.dealigned = false;\n            }\n            var linesToAlign = findAlignedLines(dv, other);\n\n            // Clear old aligners\n            var aligners = dv.mv.aligners;\n            for (var i = 0; i < aligners.length; i++)\n                aligners[i].clear();\n            aligners.length = 0;\n\n            var cm = [dv.edit, dv.orig],\n                scroll = [],\n                offset = []\n            if (other) cm.push(other.orig);\n            for (var i = 0; i < cm.length; i++) {\n                scroll.push(cm[i].getScrollInfo().top);\n                offset.push(-cm[i].getScrollerElement().getBoundingClientRect().top)\n            }\n\n            if (offset[0] != offset[1] || cm.length == 3 && offset[1] != offset[2])\n                alignLines(cm, offset, [0, 0, 0], aligners)\n            for (var ln = 0; ln < linesToAlign.length; ln++)\n                alignLines(cm, offset, linesToAlign[ln], aligners);\n\n            for (var i = 0; i < cm.length; i++)\n                cm[i].scrollTo(null, scroll[i]);\n        }\n\n        function alignLines(cm, cmOffset, lines, aligners) {\n            var maxOffset = -1e8,\n                offset = [];\n            for (var i = 0; i < cm.length; i++) if (lines[i] != null) {\n                var off = cm[i].heightAtLine(lines[i], \"local\") - cmOffset[i];\n                offset[i] = off;\n                maxOffset = Math.max(maxOffset, off);\n            }\n            for (var i = 0; i < cm.length; i++) if (lines[i] != null) {\n                var diff = maxOffset - offset[i];\n                if (diff > 1)\n                    aligners.push(padAbove(cm[i], lines[i], diff));\n            }\n        }\n\n        function padAbove(cm, line, size) {\n            var above = true;\n            if (line > cm.lastLine()) {\n                line--;\n                above = false;\n            }\n            var elt = document.createElement(\"div\");\n            elt.className = \"CodeMirror-merge-spacer\";\n            elt.style.height = size + \"px\";\n            elt.style.minWidth = \"1px\";\n            return cm.addLineWidget(line, elt, {height: size, above: above, mergeSpacer: true, handleMouseEvents: true});\n        }\n\n        function drawConnectorsForChunk(dv, chunk, sTopOrig, sTopEdit, w) {\n            var flip = dv.type == \"left\";\n            var top = dv.orig.heightAtLine(chunk.origFrom, \"local\", true) - sTopOrig;\n            if (dv.svg) {\n                var topLpx = top;\n                var topRpx = dv.edit.heightAtLine(chunk.editFrom, \"local\", true) - sTopEdit;\n                if (flip) {\n                    var tmp = topLpx;\n                    topLpx = topRpx;\n                    topRpx = tmp;\n                }\n                var botLpx = dv.orig.heightAtLine(chunk.origTo, \"local\", true) - sTopOrig;\n                var botRpx = dv.edit.heightAtLine(chunk.editTo, \"local\", true) - sTopEdit;\n                if (flip) {\n                    var tmp = botLpx;\n                    botLpx = botRpx;\n                    botRpx = tmp;\n                }\n                var curveTop = \" C \" + w / 2 + \" \" + topRpx + \" \" + w / 2 + \" \" + topLpx + \" \" + (w + 2) + \" \" + topLpx;\n                var curveBot = \" C \" + w / 2 + \" \" + botLpx + \" \" + w / 2 + \" \" + botRpx + \" -1 \" + botRpx;\n                attrs(dv.svg.appendChild(document.createElementNS(svgNS, \"path\")),\n                    \"d\", \"M -1 \" + topRpx + curveTop + \" L \" + (w + 2) + \" \" + botLpx + curveBot + \" z\",\n                    \"class\", dv.classes.connect);\n            }\n            if (dv.copyButtons) {\n                var copy = dv.copyButtons.appendChild(elt(\"div\", dv.type == \"left\" ? \"\\u21dd\" : \"\\u21dc\",\n                    \"CodeMirror-merge-copy\"));\n                var editOriginals = dv.mv.options.allowEditingOriginals;\n                copy.title = dv.edit.phrase(editOriginals ? \"Push to left\" : \"Revert chunk\");\n                copy.chunk = chunk;\n                copy.style.top = (chunk.origTo > chunk.origFrom ? top : dv.edit.heightAtLine(chunk.editFrom, \"local\") - sTopEdit) + \"px\";\n                copy.setAttribute(\"role\", \"button\");\n                copy.setAttribute(\"tabindex\", \"0\");\n                copy.setAttribute(\"aria-label\", copy.title);\n\n                if (editOriginals) {\n                    var topReverse = dv.edit.heightAtLine(chunk.editFrom, \"local\") - sTopEdit;\n                    var copyReverse = dv.copyButtons.appendChild(elt(\"div\", dv.type == \"right\" ? \"\\u21dd\" : \"\\u21dc\",\n                        \"CodeMirror-merge-copy-reverse\"));\n                    copyReverse.title = \"Push to right\";\n                    copyReverse.chunk = {\n                        editFrom: chunk.origFrom, editTo: chunk.origTo,\n                        origFrom: chunk.editFrom, origTo: chunk.editTo\n                    };\n                    copyReverse.style.top = topReverse + \"px\";\n                    dv.type == \"right\" ? copyReverse.style.left = \"2px\" : copyReverse.style.right = \"2px\";\n                    copyReverse.setAttribute(\"role\", \"button\");\n                    copyReverse.setAttribute(\"tabindex\", \"0\");\n                    copyReverse.setAttribute(\"aria-label\", copyReverse.title);\n                }\n            }\n        }\n\n        function copyChunk(dv, to, from, chunk) {\n            if (dv.diffOutOfDate) return;\n            var origStart = chunk.origTo > from.lastLine() ? Pos(chunk.origFrom - 1) : Pos(chunk.origFrom, 0)\n            var origEnd = Pos(chunk.origTo, 0)\n            var editStart = chunk.editTo > to.lastLine() ? Pos(chunk.editFrom - 1) : Pos(chunk.editFrom, 0)\n            var editEnd = Pos(chunk.editTo, 0)\n            var handler = dv.mv.options.revertChunk\n            if (handler)\n                handler(dv.mv, from, origStart, origEnd, to, editStart, editEnd)\n            else\n                to.replaceRange(from.getRange(origStart, origEnd), editStart, editEnd)\n        }\n\n        // Merge view, containing 0, 1, or 2 diff views.\n\n        var MergeView = CodeMirror.MergeView = function(node, options) {\n            if (!(this instanceof MergeView)) return new MergeView(node, options);\n\n            this.options = options;\n            var origLeft = options.origLeft,\n                origRight = options.origRight == null ? options.orig : options.origRight;\n\n            var hasLeft = origLeft != null,\n                hasRight = origRight != null;\n            var panes = 1 + (hasLeft ? 1 : 0) + (hasRight ? 1 : 0);\n            var wrap = [],\n                left = this.left = null,\n                right = this.right = null;\n            var self = this;\n\n            if (hasLeft) {\n                left = this.left = new DiffView(this, \"left\");\n                var leftPane = elt(\"div\", null, \"CodeMirror-merge-pane CodeMirror-merge-left\");\n                wrap.push(leftPane);\n                wrap.push(buildGap(left));\n            }\n\n            var editPane = elt(\"div\", null, \"CodeMirror-merge-pane CodeMirror-merge-editor\");\n            wrap.push(editPane);\n\n            if (hasRight) {\n                right = this.right = new DiffView(this, \"right\");\n                wrap.push(buildGap(right));\n                var rightPane = elt(\"div\", null, \"CodeMirror-merge-pane CodeMirror-merge-right\");\n                wrap.push(rightPane);\n            }\n\n            (hasRight ? rightPane : editPane).className += \" CodeMirror-merge-pane-rightmost\";\n\n            wrap.push(elt(\"div\", null, null, \"height: 0; clear: both;\"));\n\n            var wrapElt = this.wrap = node.appendChild(elt(\"div\", wrap, \"CodeMirror-merge CodeMirror-merge-\" + panes + \"pane\"));\n            this.edit = CodeMirror(editPane, copyObj(options));\n\n            if (left) left.init(leftPane, origLeft, options);\n            if (right) right.init(rightPane, origRight, options);\n            if (options.collapseIdentical)\n                this.editor().operation(function() {\n                    collapseIdenticalStretches(self, options.collapseIdentical);\n                });\n            if (options.connect == \"align\") {\n                this.aligners = [];\n                alignChunks(this.left || this.right, true);\n            }\n            if (left) left.registerEvents(right)\n            if (right) right.registerEvents(left)\n\n\n            var onResize = function() {\n                if (left) makeConnections(left);\n                if (right) makeConnections(right);\n            };\n            CodeMirror.on(window, \"resize\", onResize);\n            var resizeInterval = setInterval(function() {\n                for (var p = wrapElt.parentNode; p && p != document.body; p = p.parentNode) {\n                }\n                if (!p) {\n                    clearInterval(resizeInterval);\n                    CodeMirror.off(window, \"resize\", onResize);\n                }\n            }, 5000);\n        };\n\n        function buildGap(dv) {\n            var lock = dv.lockButton = elt(\"div\", null, \"CodeMirror-merge-scrolllock\");\n            lock.setAttribute(\"role\", \"button\");\n            lock.setAttribute(\"tabindex\", \"0\");\n            var lockWrap = elt(\"div\", [lock], \"CodeMirror-merge-scrolllock-wrap\");\n            CodeMirror.on(lock, \"click\", function() {\n                setScrollLock(dv, !dv.lockScroll);\n            });\n            CodeMirror.on(lock, \"keyup\", function(e) {\n                e.key === \"Enter\" && setScrollLock(dv, !dv.lockScroll);\n            });\n            var gapElts = [lockWrap];\n            if (dv.mv.options.revertButtons !== false) {\n                dv.copyButtons = elt(\"div\", null, \"CodeMirror-merge-copybuttons-\" + dv.type);\n\n                function copyButtons(e) {\n                    var node = e.target || e.srcElement;\n                    if (!node.chunk) return;\n                    if (node.className == \"CodeMirror-merge-copy-reverse\") {\n                        copyChunk(dv, dv.orig, dv.edit, node.chunk);\n                        return;\n                    }\n                    copyChunk(dv, dv.edit, dv.orig, node.chunk);\n                }\n\n                CodeMirror.on(dv.copyButtons, \"click\", copyButtons);\n                CodeMirror.on(dv.copyButtons, \"keyup\", function(e) {\n                    e.key === \"Enter\" && copyButtons(e);\n                });\n                gapElts.unshift(dv.copyButtons);\n            }\n            if (dv.mv.options.connect != \"align\") {\n                var svg = document.createElementNS && document.createElementNS(svgNS, \"svg\");\n                if (svg && !svg.createSVGRect) svg = null;\n                dv.svg = svg;\n                if (svg) gapElts.push(svg);\n            }\n\n            return dv.gap = elt(\"div\", gapElts, \"CodeMirror-merge-gap\");\n        }\n\n        MergeView.prototype = {\n            constructor: MergeView,\n            editor: function() {\n                return this.edit;\n            },\n            rightOriginal: function() {\n                return this.right && this.right.orig;\n            },\n            leftOriginal: function() {\n                return this.left && this.left.orig;\n            },\n            setShowDifferences: function(val) {\n                if (this.right) this.right.setShowDifferences(val);\n                if (this.left) this.left.setShowDifferences(val);\n            },\n            rightChunks: function() {\n                if (this.right) {\n                    ensureDiff(this.right);\n                    return this.right.chunks;\n                }\n            },\n            leftChunks: function() {\n                if (this.left) {\n                    ensureDiff(this.left);\n                    return this.left.chunks;\n                }\n            }\n        };\n\n        function asString(obj) {\n            if (typeof obj == \"string\") return obj;\n            else return obj.getValue();\n        }\n\n        // Operations on diffs\n        var dmp;\n\n        function getDiff(a, b, ignoreWhitespace) {\n            if (!dmp) dmp = new diff_match_patch();\n\n            var diff = dmp.diff_main(a, b);\n            // The library sometimes leaves in empty parts, which confuse the algorithm\n            for (var i = 0; i < diff.length; ++i) {\n                var part = diff[i];\n                if (ignoreWhitespace ? !/[^ \\t]/.test(part[1]) : !part[1]) {\n                    diff.splice(i--, 1);\n                } else if (i && diff[i - 1][0] == part[0]) {\n                    diff.splice(i--, 1);\n                    diff[i][1] += part[1];\n                }\n            }\n            return diff;\n        }\n\n        function getChunks(diff) {\n            var chunks = [];\n            if (!diff.length) return chunks;\n            var startEdit = 0,\n                startOrig = 0;\n            var edit = Pos(0, 0),\n                orig = Pos(0, 0);\n            for (var i = 0; i < diff.length; ++i) {\n                var part = diff[i],\n                    tp = part[0];\n                if (tp == DIFF_EQUAL) {\n                    var startOff = !startOfLineClean(diff, i) || edit.line < startEdit || orig.line < startOrig ? 1 : 0;\n                    var cleanFromEdit = edit.line + startOff,\n                        cleanFromOrig = orig.line + startOff;\n                    moveOver(edit, part[1], null, orig);\n                    var endOff = endOfLineClean(diff, i) ? 1 : 0;\n                    var cleanToEdit = edit.line + endOff,\n                        cleanToOrig = orig.line + endOff;\n                    if (cleanToEdit > cleanFromEdit) {\n                        if (i) chunks.push({\n                            origFrom: startOrig, origTo: cleanFromOrig,\n                            editFrom: startEdit, editTo: cleanFromEdit\n                        });\n                        startEdit = cleanToEdit;\n                        startOrig = cleanToOrig;\n                    }\n                } else {\n                    moveOver(tp == DIFF_INSERT ? edit : orig, part[1]);\n                }\n            }\n            if (startEdit <= edit.line || startOrig <= orig.line)\n                chunks.push({\n                    origFrom: startOrig, origTo: orig.line + 1,\n                    editFrom: startEdit, editTo: edit.line + 1\n                });\n            return chunks;\n        }\n\n        function endOfLineClean(diff, i) {\n            if (i == diff.length - 1) return true;\n            var next = diff[i + 1][1];\n            if ((next.length == 1 && i < diff.length - 2) || next.charCodeAt(0) != 10) return false;\n            if (i == diff.length - 2) return true;\n            next = diff[i + 2][1];\n            return (next.length > 1 || i == diff.length - 3) && next.charCodeAt(0) == 10;\n        }\n\n        function startOfLineClean(diff, i) {\n            if (i == 0) return true;\n            var last = diff[i - 1][1];\n            if (last.charCodeAt(last.length - 1) != 10) return false;\n            if (i == 1) return true;\n            last = diff[i - 2][1];\n            return last.charCodeAt(last.length - 1) == 10;\n        }\n\n        function chunkBoundariesAround(chunks, n, nInEdit) {\n            var beforeE,\n                afterE,\n                beforeO,\n                afterO;\n            for (var i = 0; i < chunks.length; i++) {\n                var chunk = chunks[i];\n                var fromLocal = nInEdit ? chunk.editFrom : chunk.origFrom;\n                var toLocal = nInEdit ? chunk.editTo : chunk.origTo;\n                if (afterE == null) {\n                    if (fromLocal > n) {\n                        afterE = chunk.editFrom;\n                        afterO = chunk.origFrom;\n                    } else if (toLocal > n) {\n                        afterE = chunk.editTo;\n                        afterO = chunk.origTo;\n                    }\n                }\n                if (toLocal <= n) {\n                    beforeE = chunk.editTo;\n                    beforeO = chunk.origTo;\n                } else if (fromLocal <= n) {\n                    beforeE = chunk.editFrom;\n                    beforeO = chunk.origFrom;\n                }\n            }\n            return {edit: {before: beforeE, after: afterE}, orig: {before: beforeO, after: afterO}};\n        }\n\n        function collapseSingle(cm, from, to) {\n            cm.addLineClass(from, \"wrap\", \"CodeMirror-merge-collapsed-line\");\n            var widget = document.createElement(\"span\");\n            widget.className = \"CodeMirror-merge-collapsed-widget\";\n            widget.title = cm.phrase(\"Identical text collapsed. Click to expand.\");\n            var mark = cm.markText(Pos(from, 0), Pos(to - 1), {\n                inclusiveLeft: true,\n                inclusiveRight: true,\n                replacedWith: widget,\n                clearOnEnter: true\n            });\n\n            function clear() {\n                mark.clear();\n                cm.removeLineClass(from, \"wrap\", \"CodeMirror-merge-collapsed-line\");\n            }\n\n            if (mark.explicitlyCleared) clear();\n            CodeMirror.on(widget, \"click\", clear);\n            mark.on(\"clear\", clear);\n            CodeMirror.on(widget, \"click\", clear);\n            return {mark: mark, clear: clear};\n        }\n\n        function collapseStretch(size, editors) {\n            var marks = [];\n\n            function clear() {\n                for (var i = 0; i < marks.length; i++) marks[i].clear();\n            }\n\n            for (var i = 0; i < editors.length; i++) {\n                var editor = editors[i];\n                var mark = collapseSingle(editor.cm, editor.line, editor.line + size);\n                marks.push(mark);\n                mark.mark.on(\"clear\", clear);\n            }\n            return marks[0].mark;\n        }\n\n        function unclearNearChunks(dv, margin, off, clear) {\n            for (var i = 0; i < dv.chunks.length; i++) {\n                var chunk = dv.chunks[i];\n                for (var l = chunk.editFrom - margin; l < chunk.editTo + margin; l++) {\n                    var pos = l + off;\n                    if (pos >= 0 && pos < clear.length) clear[pos] = false;\n                }\n            }\n        }\n\n        function collapseIdenticalStretches(mv, margin) {\n            if (typeof margin != \"number\") margin = 2;\n            var clear = [],\n                edit = mv.editor(),\n                off = edit.firstLine();\n            for (var l = off, e = edit.lastLine(); l <= e; l++) clear.push(true);\n            if (mv.left) unclearNearChunks(mv.left, margin, off, clear);\n            if (mv.right) unclearNearChunks(mv.right, margin, off, clear);\n\n            for (var i = 0; i < clear.length; i++) {\n                if (clear[i]) {\n                    var line = i + off;\n                    for (var size = 1; i < clear.length - 1 && clear[i + 1]; i++, size++) {\n                    }\n                    if (size > margin) {\n                        var editors = [{line: line, cm: edit}];\n                        if (mv.left) editors.push({line: getMatchingOrigLine(line, mv.left.chunks), cm: mv.left.orig});\n                        if (mv.right) editors.push({line: getMatchingOrigLine(line, mv.right.chunks), cm: mv.right.orig});\n                        var mark = collapseStretch(size, editors);\n                        if (mv.options.onCollapse) mv.options.onCollapse(mv, line, size, mark);\n                    }\n                }\n            }\n        }\n\n        // General utilities\n\n        function elt(tag, content, className, style) {\n            var e = document.createElement(tag);\n            if (className) e.className = className;\n            if (style) e.style.cssText = style;\n            if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n            else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n            return e;\n        }\n\n        function clear(node) {\n            for (var count = node.childNodes.length; count > 0; --count)\n                node.removeChild(node.firstChild);\n        }\n\n        function attrs(elt) {\n            for (var i = 1; i < arguments.length; i += 2)\n                elt.setAttribute(arguments[i], arguments[i + 1]);\n        }\n\n        function copyObj(obj, target) {\n            if (!target) target = {};\n            for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];\n            return target;\n        }\n\n        function moveOver(pos, str, copy, other) {\n            var out = copy ? Pos(pos.line, pos.ch) : pos,\n                at = 0;\n            for (; ;) {\n                var nl = str.indexOf(\"\\n\", at);\n                if (nl == -1) break;\n                ++out.line;\n                if (other) ++other.line;\n                at = nl + 1;\n            }\n            out.ch = (at ? 0 : out.ch) + (str.length - at);\n            if (other) other.ch = (at ? 0 : other.ch) + (str.length - at);\n            return out;\n        }\n\n        // Tracks collapsed markers and line widgets, in order to be able to\n        // accurately align the content of two editors.\n\n        var F_WIDGET = 1,\n            F_WIDGET_BELOW = 2,\n            F_MARKER = 4\n\n        function TrackAlignable(cm) {\n            this.cm = cm\n            this.alignable = []\n            this.height = cm.doc.height\n            var self = this\n            cm.on(\"markerAdded\", function(_, marker) {\n                if (!marker.collapsed) return\n                var found = marker.find(1)\n                if (found != null) self.set(found.line, F_MARKER)\n            })\n            cm.on(\"markerCleared\", function(_, marker, _min, max) {\n                if (max != null && marker.collapsed)\n                    self.check(max, F_MARKER, self.hasMarker)\n            })\n            cm.on(\"markerChanged\", this.signal.bind(this))\n            cm.on(\"lineWidgetAdded\", function(_, widget, lineNo) {\n                if (widget.mergeSpacer) return\n                if (widget.above) self.set(lineNo - 1, F_WIDGET_BELOW)\n                else self.set(lineNo, F_WIDGET)\n            })\n            cm.on(\"lineWidgetCleared\", function(_, widget, lineNo) {\n                if (widget.mergeSpacer) return\n                if (widget.above) self.check(lineNo - 1, F_WIDGET_BELOW, self.hasWidgetBelow)\n                else self.check(lineNo, F_WIDGET, self.hasWidget)\n            })\n            cm.on(\"lineWidgetChanged\", this.signal.bind(this))\n            cm.on(\"change\", function(_, change) {\n                var start = change.from.line,\n                    nBefore = change.to.line - change.from.line\n                var nAfter = change.text.length - 1,\n                    end = start + nAfter\n                if (nBefore || nAfter) self.map(start, nBefore, nAfter)\n                self.check(end, F_MARKER, self.hasMarker)\n                if (nBefore || nAfter) self.check(change.from.line, F_MARKER, self.hasMarker)\n            })\n            cm.on(\"viewportChange\", function() {\n                if (self.cm.doc.height != self.height) self.signal()\n            })\n        }\n\n        TrackAlignable.prototype = {\n            signal: function() {\n                CodeMirror.signal(this, \"realign\")\n                this.height = this.cm.doc.height\n            },\n\n            set: function(n, flags) {\n                var pos = -1\n                for (; pos < this.alignable.length; pos += 2) {\n                    var diff = this.alignable[pos] - n\n                    if (diff == 0) {\n                        if ((this.alignable[pos + 1] & flags) == flags) return\n                        this.alignable[pos + 1] |= flags\n                        this.signal()\n                        return\n                    }\n                    if (diff > 0) break\n                }\n                this.signal()\n                this.alignable.splice(pos, 0, n, flags)\n            },\n\n            find: function(n) {\n                for (var i = 0; i < this.alignable.length; i += 2)\n                    if (this.alignable[i] == n) return i\n                return -1\n            },\n\n            check: function(n, flag, pred) {\n                var found = this.find(n)\n                if (found == -1 || !(this.alignable[found + 1] & flag)) return\n                if (!pred.call(this, n)) {\n                    this.signal()\n                    var flags = this.alignable[found + 1] & ~flag\n                    if (flags) this.alignable[found + 1] = flags\n                    else this.alignable.splice(found, 2)\n                }\n            },\n\n            hasMarker: function(n) {\n                var handle = this.cm.getLineHandle(n)\n                if (handle.markedSpans) for (var i = 0; i < handle.markedSpans.length; i++)\n                    if (handle.markedSpans[i].marker.collapsed && handle.markedSpans[i].to != null)\n                        return true\n                return false\n            },\n\n            hasWidget: function(n) {\n                var handle = this.cm.getLineHandle(n)\n                if (handle.widgets) for (var i = 0; i < handle.widgets.length; i++)\n                    if (!handle.widgets[i].above && !handle.widgets[i].mergeSpacer) return true\n                return false\n            },\n\n            hasWidgetBelow: function(n) {\n                if (n == this.cm.lastLine()) return false\n                var handle = this.cm.getLineHandle(n + 1)\n                if (handle.widgets) for (var i = 0; i < handle.widgets.length; i++)\n                    if (handle.widgets[i].above && !handle.widgets[i].mergeSpacer) return true\n                return false\n            },\n\n            map: function(from, nBefore, nAfter) {\n                var diff = nAfter - nBefore,\n                    to = from + nBefore,\n                    widgetFrom = -1,\n                    widgetTo = -1\n                for (var i = 0; i < this.alignable.length; i += 2) {\n                    var n = this.alignable[i]\n                    if (n == from && (this.alignable[i + 1] & F_WIDGET_BELOW)) widgetFrom = i\n                    if (n == to && (this.alignable[i + 1] & F_WIDGET_BELOW)) widgetTo = i\n                    if (n <= from) continue\n                    else if (n < to) this.alignable.splice(i--, 2)\n                    else this.alignable[i] += diff\n                }\n                if (widgetFrom > -1) {\n                    var flags = this.alignable[widgetFrom + 1]\n                    if (flags == F_WIDGET_BELOW) this.alignable.splice(widgetFrom, 2)\n                    else this.alignable[widgetFrom + 1] = flags & ~F_WIDGET_BELOW\n                }\n                if (widgetTo > -1 && nAfter)\n                    this.set(from + nAfter, F_WIDGET_BELOW)\n            }\n        }\n\n        function posMin(a, b) {\n            return (a.line - b.line || a.ch - b.ch) < 0 ? a : b;\n        }\n\n        function posMax(a, b) {\n            return (a.line - b.line || a.ch - b.ch) > 0 ? a : b;\n        }\n\n        function posEq(a, b) {\n            return a.line == b.line && a.ch == b.ch;\n        }\n\n        function findPrevDiff(chunks, start, isOrig) {\n            for (var i = chunks.length - 1; i >= 0; i--) {\n                var chunk = chunks[i];\n                var to = (isOrig ? chunk.origTo : chunk.editTo) - 1;\n                if (to < start) return to;\n            }\n        }\n\n        function findNextDiff(chunks, start, isOrig) {\n            for (var i = 0; i < chunks.length; i++) {\n                var chunk = chunks[i];\n                var from = (isOrig ? chunk.origFrom : chunk.editFrom);\n                if (from > start) return from;\n            }\n        }\n\n        function goNearbyDiff(cm, dir) {\n            var found = null,\n                views = cm.state.diffViews,\n                line = cm.getCursor().line;\n            if (views) for (var i = 0; i < views.length; i++) {\n                var dv = views[i],\n                    isOrig = cm == dv.orig;\n                ensureDiff(dv);\n                var pos = dir < 0 ? findPrevDiff(dv.chunks, line, isOrig) : findNextDiff(dv.chunks, line, isOrig);\n                if (pos != null && (found == null || (dir < 0 ? pos > found : pos < found)))\n                    found = pos;\n            }\n            if (found != null)\n                cm.setCursor(found, 0);\n            else\n                return CodeMirror.Pass;\n        }\n\n        CodeMirror.commands.goNextDiff = function(cm) {\n            return goNearbyDiff(cm, 1);\n        };\n        CodeMirror.commands.goPrevDiff = function(cm) {\n            return goNearbyDiff(cm, -1);\n        };\n\n        return {\n            DiffView: DiffView,\n            MergeView: MergeView\n        }\n});"],"names":["diff_match_patch","Diff_Timeout","Diff_EditCost","Match_Threshold","Match_Distance","Patch_DeleteThreshold","Patch_Margin","Match_MaxBits","Diff","prototype","diff_main","text1","text2","opt_checklines","opt_deadline","this","Number","MAX_VALUE","Date","getTime","deadline","Error","checklines","commonlength","diff_commonPrefix","commonprefix","substring","diff_commonSuffix","commonsuffix","length","diffs","diff_compute_","unshift","push","diff_cleanupMerge","longtext","shorttext","i","indexOf","hm","diff_halfMatch_","text1_a","text1_b","text2_a","text2_b","mid_common","diffs_a","diffs_b","concat","diff_lineMode_","diff_bisect_","a","diff_linesToChars_","chars1","chars2","linearray","lineArray","diff_charsToLines_","diff_cleanupSemantic","pointer","count_delete","count_insert","text_delete","text_insert","splice","j","pop","text1_length","text2_length","max_d","Math","ceil","v_offset","v_length","v1","Array","v2","x","delta","front","k1start","k1end","k2start","k2end","d","k1","k1_offset","y1","x1","charAt","k2_offset","x2","diff_bisectSplit_","k2","y2","y","text1a","text2a","text1b","text2b","diffsb","lineHash","diff_linesToCharsMunge_","text","chars","lineStart","lineEnd","lineArrayLength","line","hasOwnProperty","undefined","String","fromCharCode","charCodeAt","join","pointermin","pointermax","min","pointermid","pointerstart","floor","pointerend","diff_commonOverlap_","text_length","best","pattern","found","dmp","diff_halfMatchI_","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","best_common","prefixLength","suffixLength","hm1","hm2","changes","equalities","equalitiesLength","lastequality","length_insertions1","length_deletions1","length_insertions2","length_deletions2","max","diff_cleanupSemanticLossless","deletion","insertion","overlap_length1","overlap_length2","diff_cleanupSemanticScore_","one","two","char1","char2","nonAlphaNumeric1","match","nonAlphaNumericRegex_","nonAlphaNumeric2","whitespace1","whitespaceRegex_","whitespace2","lineBreak1","linebreakRegex_","lineBreak2","blankLine1","blanklineEndRegex_","blankLine2","blanklineStartRegex_","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","score","diff_cleanupEfficiency","pre_ins","pre_del","post_ins","post_del","diff_xIndex","loc","last_chars1","last_chars2","diff_prettyHtml","html","pattern_amp","pattern_lt","pattern_gt","pattern_para","op","replace","diff_text1","diff_text2","diff_levenshtein","levenshtein","insertions","deletions","data","diff_toDelta","encodeURI","diff_fromDelta","diffsLength","tokens","split","param","decodeURI","ex","n","parseInt","isNaN","match_main","match_bitap_","s","match_alphabet_","match_bitapScore_","e","accuracy","proximity","abs","score_threshold","best_loc","lastIndexOf","bin_min","bin_mid","matchmask","last_rd","bin_max","start","finish","rd","charMatch","patch_addContext_","patch","start2","length1","padding","prefix","suffix","start1","length2","patch_make","opt_b","opt_c","patches","patch_obj","patchDiffLength","char_count1","char_count2","prepatch_text","postpatch_text","diff_type","diff_text","patch_deepCopy","patchesCopy","patchCopy","slice","patch_apply","nullPadding","patch_addPadding","patch_splitMax","results","start_loc","expected_loc","end_loc","index2","index1","mod","paddingLength","extraLength","patch_size","bigpatch","precontext","empty","shift","postcontext","patch_toText","patch_fromText","textline","textPointer","patchHeader","m","sign","toString","define","CodeMirror","Pos","svgNS","DiffView","mv","type","classes","chunk","end","insert","del","connect","ensureDiff","dv","diffOutOfDate","diff","getDiff","orig","getValue","options","ignoreWhitespace","chunks","getChunks","signal","constructor","init","pane","state","diffViews","copyObj","value","readOnly","allowEditingOriginals","trackAlignable","TrackAlignable","lockButton","title","phrase","setAttribute","classLocation","chunkClassLocation","Object","call","asString","dealigned","needsScrollSync","showDifferences","registerEvents","otherDv","forceUpdate","debounceChange","from","to","marked","updatingFast","update","mode","updating","svg","clear","copyButtons","clearMarks","updateMarks","alignChunks","makeConnections","syncScroll","setDealign","fast","set","clearTimeout","setTimeout","change","_cm","swapDoc","on","registerUpdate","setScrollLock","registerScroll","setShowDifferences","val","toOrig","lockScroll","editor","other","now","scrollSetBy","scrollSetAt","sInfo","getScrollInfo","targetPos","top","botDist","mix","halfScreen","clientHeight","midY","mid","lineAtHeight","around","nInEdit","beforeE","afterE","beforeO","afterO","fromLocal","editFrom","origFrom","toLocal","editTo","origTo","before","after","chunkBoundariesAround","off","getOffsets","offOther","ratio","bot","height","otherInfo","scrollTo","left","lastLine","heightAtLine","action","addClass","rmClass","removeClass","locs","removeLineClass","arr","mark","TextMarker","parent","vp","getViewport","operation","markChanges","lineNr","main","getLineHandle","addLineClass","marks","pos","clipPos","cls","markChunk","bfrom","bto","chunkStart","pending","part","tp","str","cleanFrom","startOfLineClean","moveOver","cleanTo","endOfLineClean","posMax","b","posMin","posEq","markText","className","w","gap","offsetWidth","attrs","offsetHeight","vpEdit","vpOrig","outerTop","wrap","getBoundingClientRect","sTopEdit","getScrollerElement","sTopOrig","ch","drawConnectorsForChunk","getMatchingOrigLine","editLine","editStart","origStart","alignableFor","cm","isOrig","tracker","firstLine","trackI","result","alignable","mergeAlignable","origAlignable","setIndex","rI","origI","chunkI","outer","nextR","nextO","rLine","oLine","record","force","curOp","right","linesToAlign","findAlignedLines","aligners","scroll","offset","alignLines","ln","cmOffset","lines","maxOffset","padAbove","size","above","elt","document","createElement","style","minWidth","addLineWidget","mergeSpacer","handleMouseEvents","flip","topLpx","topRpx","tmp","botLpx","botRpx","curveTop","curveBot","appendChild","createElementNS","copy","editOriginals","topReverse","copyReverse","copyChunk","origEnd","editEnd","handler","revertChunk","replaceRange","getRange","MergeView","node","origLeft","origRight","hasLeft","hasRight","panes","self","leftPane","buildGap","editPane","rightPane","wrapElt","collapseIdentical","margin","l","unclearNearChunks","editors","collapseStretch","onCollapse","collapseIdenticalStretches","onResize","window","resizeInterval","setInterval","p","parentNode","body","clearInterval","lock","lockWrap","key","gapElts","revertButtons","target","srcElement","createSVGRect","obj","test","startEdit","startOrig","startOff","cleanFromEdit","cleanFromOrig","endOff","cleanToEdit","cleanToOrig","next","last","collapseSingle","widget","inclusiveLeft","inclusiveRight","replacedWith","clearOnEnter","explicitlyCleared","tag","content","cssText","createTextNode","count","childNodes","removeChild","firstChild","arguments","prop","out","at","nl","rightOriginal","leftOriginal","rightChunks","leftChunks","doc","_","marker","collapsed","find","_min","check","hasMarker","bind","lineNo","hasWidgetBelow","hasWidget","nBefore","nAfter","map","findPrevDiff","findNextDiff","goNearbyDiff","dir","views","getCursor","Pass","setCursor","flags","flag","pred","handle","markedSpans","widgets","widgetFrom","widgetTo","commands","goNextDiff","goPrevDiff"],"mappings":"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"}